/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import type * as Fetcher from "./entityServiceFetcher";
import { entityServiceFetch } from "./entityServiceFetcher";
import type * as Schemas from "./entityServiceSchemas";

export type ProjectPitchIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  search?: string;
  /**
   * Search query used for filtering selectable options in autocomplete fields.
   */
  filter?: Schemas.FilterItem;
};

export type ProjectPitchIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type ProjectPitchIndexResponse = {
  meta?: {
    /**
     * @example projectPitches
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The current page number.
       */
      pageNumber?: number;
      /**
       * The ordered set of resource IDs for this page of this index search.
       */
      ids?: string[];
    }[];
  };
  data?: {
    /**
     * @example projectPitches
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ProjectPitchDto;
  }[];
};

export type ProjectPitchIndexVariables = {
  queryParams?: ProjectPitchIndexQueryParams;
};

export const projectPitchIndex = (variables: ProjectPitchIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    ProjectPitchIndexResponse,
    ProjectPitchIndexError,
    undefined,
    {},
    ProjectPitchIndexQueryParams,
    {}
  >({ url: "/entities/v3/projectPitches", method: "get", ...variables, signal });

export type ProjectPitchGetPathParams = {
  /**
   * Entity UUID for association
   */
  uuid: string;
};

export type ProjectPitchGetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type ProjectPitchGetResponse = {
  meta?: {
    /**
     * @example projectPitches
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example projectPitches
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ProjectPitchDto;
  };
};

export type ProjectPitchGetVariables = {
  pathParams: ProjectPitchGetPathParams;
};

export const projectPitchGet = (variables: ProjectPitchGetVariables, signal?: AbortSignal) =>
  entityServiceFetch<ProjectPitchGetResponse, ProjectPitchGetError, undefined, {}, {}, ProjectPitchGetPathParams>({
    url: "/entities/v3/projectPitches/{uuid}",
    method: "get",
    ...variables,
    signal
  });

export type ImpactStoryIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  search?: string;
  country?: string;
  /**
   * Filter results by organisationType
   */
  ["organisationType[]"]?: ("for-profit-organization" | "non-profit-organization")[];
  projectUuid?: string;
  category?: string;
};

export type ImpactStoryIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type ImpactStoryIndexResponse = {
  meta?: {
    /**
     * @example impactStories
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The current page number.
       */
      pageNumber?: number;
      /**
       * The ordered set of resource IDs for this page of this index search.
       */
      ids?: string[];
    }[];
  };
  data?: {
    /**
     * @example impactStories
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ImpactStoryLightDto;
  }[];
};

export type ImpactStoryIndexVariables = {
  queryParams?: ImpactStoryIndexQueryParams;
};

export const impactStoryIndex = (variables: ImpactStoryIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<ImpactStoryIndexResponse, ImpactStoryIndexError, undefined, {}, ImpactStoryIndexQueryParams, {}>({
    url: "/entities/v3/impactStories",
    method: "get",
    ...variables,
    signal
  });

export type ImpactStoryGetPathParams = {
  /**
   * Impact Story UUID
   */
  uuid: string;
};

export type ImpactStoryGetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type ImpactStoryGetResponse = {
  meta?: {
    /**
     * @example impactStories
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example impactStories
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ImpactStoryFullDto;
  };
};

export type ImpactStoryGetVariables = {
  pathParams: ImpactStoryGetPathParams;
};

export const impactStoryGet = (variables: ImpactStoryGetVariables, signal?: AbortSignal) =>
  entityServiceFetch<ImpactStoryGetResponse, ImpactStoryGetError, undefined, {}, {}, ImpactStoryGetPathParams>({
    url: "/entities/v3/impactStories/{uuid}",
    method: "get",
    ...variables,
    signal
  });

export type TaskIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  status?: string;
  frameworkKey?: string;
  projectUuid?: string;
};

export type TaskIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type TaskIndexResponse = {
  meta?: {
    /**
     * @example tasks
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The current page number.
       */
      pageNumber?: number;
      /**
       * The ordered set of resource IDs for this page of this index search.
       */
      ids?: string[];
    }[];
  };
  data?: {
    /**
     * @example tasks
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.TaskLightDto;
  }[];
  included?: (
    | {
        /**
         * @example projectReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ProjectReportLightDto;
      }
    | {
        /**
         * @example siteReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SiteReportLightDto;
      }
    | {
        /**
         * @example nurseryReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.NurseryReportLightDto;
      }
  )[];
};

export type TaskIndexVariables = {
  queryParams?: TaskIndexQueryParams;
};

export const taskIndex = (variables: TaskIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<TaskIndexResponse, TaskIndexError, undefined, {}, TaskIndexQueryParams, {}>({
    url: "/entities/v3/tasks",
    method: "get",
    ...variables,
    signal
  });

export type BulkApproveTasksQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  status?: string;
  frameworkKey?: string;
  projectUuid?: string;
};

export type BulkApproveTasksError = Fetcher.ErrorWrapper<undefined>;

export type BulkApproveTasksResponse = {
  meta?: {
    /**
     * @example tasks
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The current page number.
       */
      pageNumber?: number;
      /**
       * The ordered set of resource IDs for this page of this index search.
       */
      ids?: string[];
    }[];
  };
  data?: {
    /**
     * @example tasks
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.TaskLightDto;
  }[];
  included?: (
    | {
        /**
         * @example projectReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ProjectReportLightDto;
      }
    | {
        /**
         * @example siteReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SiteReportLightDto;
      }
    | {
        /**
         * @example nurseryReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.NurseryReportLightDto;
      }
  )[];
};

export type BulkApproveTasksVariables = {
  body: Schemas.BulkTaskUpdateBody;
  queryParams?: BulkApproveTasksQueryParams;
};

export const bulkApproveTasks = (variables: BulkApproveTasksVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    BulkApproveTasksResponse,
    BulkApproveTasksError,
    Schemas.BulkTaskUpdateBody,
    {},
    BulkApproveTasksQueryParams,
    {}
  >({ url: "/entities/v3/tasks", method: "patch", ...variables, signal });

export type TaskGetPathParams = {
  /**
   * Task UUID for task to retrieve
   */
  uuid: string;
};

export type TaskGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type TaskGetResponse = {
  meta?: {
    /**
     * @example tasks
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example tasks
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.TaskFullDto;
    relationships?: {
      projectReport?: {
        /**
         * @example projectReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
      };
      siteReports?: {
        /**
         * @example siteReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
      }[];
      nurseryReports?: {
        /**
         * @example nurseryReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
      }[];
    };
  };
  included?: (
    | {
        /**
         * @example projectReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ProjectReportLightDto;
      }
    | {
        /**
         * @example siteReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SiteReportLightDto;
      }
    | {
        /**
         * @example nurseryReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.NurseryReportLightDto;
      }
  )[];
};

export type TaskGetVariables = {
  pathParams: TaskGetPathParams;
};

export const taskGet = (variables: TaskGetVariables, signal?: AbortSignal) =>
  entityServiceFetch<TaskGetResponse, TaskGetError, undefined, {}, {}, TaskGetPathParams>({
    url: "/entities/v3/tasks/{uuid}",
    method: "get",
    ...variables,
    signal
  });

export type TaskUpdatePathParams = {
  /**
   * Task UUID for task to retrieve
   */
  uuid: string;
};

export type TaskUpdateQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  status?: string;
  frameworkKey?: string;
  projectUuid?: string;
};

export type TaskUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type TaskUpdateResponse = {
  meta?: {
    /**
     * @example tasks
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example tasks
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.TaskFullDto;
  };
  included?: (
    | {
        /**
         * @example projectReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ProjectReportLightDto;
      }
    | {
        /**
         * @example siteReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SiteReportLightDto;
      }
    | {
        /**
         * @example nurseryReports
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.NurseryReportLightDto;
      }
  )[];
};

export type TaskUpdateVariables = {
  body: Schemas.TaskUpdateBody;
  pathParams: TaskUpdatePathParams;
  queryParams?: TaskUpdateQueryParams;
};

export const taskUpdate = (variables: TaskUpdateVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    TaskUpdateResponse,
    TaskUpdateError,
    Schemas.TaskUpdateBody,
    {},
    TaskUpdateQueryParams,
    TaskUpdatePathParams
  >({ url: "/entities/v3/tasks/{uuid}", method: "patch", ...variables, signal });

export type UploadFilePathParams = {
  /**
   * Entity type to retrieve
   */
  entity:
    | "projects"
    | "sites"
    | "nurseries"
    | "projectReports"
    | "siteReports"
    | "nurseryReports"
    | "organisations"
    | "auditStatuses"
    | "forms"
    | "formQuestionOptions"
    | "fundingProgrammes"
    | "impactStories"
    | "financialIndicators";
  /**
   * Entity UUID for resource to retrieve
   */
  uuid: string;
  /**
   * Media collection to retrieve
   */
  collection: string;
};

export type UploadFileError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UploadFileResponse = {
  meta?: {
    /**
     * @example media
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example media
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.MediaDto;
  };
};

export type UploadFileVariables = {
  pathParams: UploadFilePathParams;
};

/**
 * Upload a file to a media collection
 */
export const uploadFile = (variables: UploadFileVariables, signal?: AbortSignal) =>
  entityServiceFetch<UploadFileResponse, UploadFileError, undefined, {}, {}, UploadFilePathParams>({
    url: "/entities/v3/files/{entity}/{uuid}/{collection}",
    method: "post",
    ...variables,
    signal
  });

export type TreeScientificNamesSearchQueryParams = {
  search: string;
};

export type TreeScientificNamesSearchError = Fetcher.ErrorWrapper<undefined>;

export type TreeScientificNamesSearchResponse = {
  meta?: {
    /**
     * @example treeSpeciesScientificNames
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example treeSpeciesScientificNames
     */
    type?: string;
    id?: string;
    attributes?: Schemas.ScientificNameDto;
  }[];
};

export type TreeScientificNamesSearchVariables = {
  queryParams: TreeScientificNamesSearchQueryParams;
};

/**
 * Search scientific names of tree species. Returns up to 10 entries.
 */
export const treeScientificNamesSearch = (variables: TreeScientificNamesSearchVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    TreeScientificNamesSearchResponse,
    TreeScientificNamesSearchError,
    undefined,
    {},
    TreeScientificNamesSearchQueryParams,
    {}
  >({ url: "/trees/v3/scientificNames", method: "get", ...variables, signal });

export type EstablishmentTreesFindPathParams = {
  /**
   * Entity type for which to retrieve the establishment tree data.
   */
  entity: "sites" | "nurseries" | "projectReports" | "siteReports" | "nurseryReports";
  /**
   * Entity UUID for which to retrieve the establishment tree data.
   */
  uuid: string;
};

export type EstablishmentTreesFindError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type EstablishmentTreesFindResponse = {
  meta?: {
    /**
     * @example establishmentTrees
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example establishmentTrees
     */
    type?: string;
    id?: string;
    attributes?: Schemas.EstablishmentsTreesDto;
  };
};

export type EstablishmentTreesFindVariables = {
  pathParams: EstablishmentTreesFindPathParams;
};

export const establishmentTreesFind = (variables: EstablishmentTreesFindVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    EstablishmentTreesFindResponse,
    EstablishmentTreesFindError,
    undefined,
    {},
    {},
    EstablishmentTreesFindPathParams
  >({ url: "/trees/v3/establishments/{entity}/{uuid}", method: "get", ...variables, signal });

export type TreeReportCountsFindPathParams = {
  /**
   * Entity type for which to retrieve the associated report count data.
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "siteReports" | "nurseryReports";
  /**
   * Entity UUID for which to retrieve the associated report count data.
   */
  uuid: string;
};

export type TreeReportCountsFindError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type TreeReportCountsFindResponse = {
  meta?: {
    /**
     * @example treeReportCounts
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example treeReportCounts
     */
    type?: string;
    id?: string;
    attributes?: Schemas.TreeReportCountsDto;
  };
};

export type TreeReportCountsFindVariables = {
  pathParams: TreeReportCountsFindPathParams;
};

export const treeReportCountsFind = (variables: TreeReportCountsFindVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    TreeReportCountsFindResponse,
    TreeReportCountsFindError,
    undefined,
    {},
    {},
    TreeReportCountsFindPathParams
  >({ url: "/trees/v3/reportCounts/{entity}/{uuid}", method: "get", ...variables, signal });

export type DemographicsIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * project uuid array
   */
  projectUuid?: string[];
  /**
   * projectReport uuid array
   */
  projectReportUuid?: string[];
  /**
   * siteReport uuid array
   */
  siteReportUuid?: string[];
};

export type DemographicsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DemographicsIndexResponse = {
  meta?: {
    /**
     * @example demographics
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The current page number.
       */
      pageNumber?: number;
      /**
       * The ordered set of resource IDs for this page of this index search.
       */
      ids?: string[];
    }[];
  };
  data?: {
    /**
     * @example demographics
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.DemographicDto;
  }[];
};

export type DemographicsIndexVariables = {
  queryParams?: DemographicsIndexQueryParams;
};

export const demographicsIndex = (variables: DemographicsIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    DemographicsIndexResponse,
    DemographicsIndexError,
    undefined,
    {},
    DemographicsIndexQueryParams,
    {}
  >({ url: "/entities/v3/demographics", method: "get", ...variables, signal });

export type EntityIndexPathParams = {
  /**
   * Entity type to retrieve
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "nurseryReports" | "siteReports";
};

export type EntityIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  search?: string;
  /**
   * Search query used for filtering selectable options in autocomplete fields.
   */
  searchFilter?: string;
  country?: string;
  status?: string;
  updateRequestStatus?: string;
  projectUuid?: string;
  nurseryUuid?: string;
  siteUuid?: string;
  /**
   * Filter by landscape 3-letter codes: gcb, grv, ikr
   */
  landscape?: string[];
  /**
   * Filter by organisation types
   */
  organisationType?: string[];
  /**
   * Filter by cohorts
   */
  cohort?: string[];
  /**
   * If the base entity supports it, this will load the first page of associated entities
   */
  sideloads?: Schemas.EntitySideload[];
  polygonStatus?: "no-polygons" | "submitted" | "approved" | "needs-more-information" | "draft";
  nothingToReport?: boolean;
  shortName?: string;
  /**
   * Filter by UUIDs
   */
  uuids?: string[];
};

export type EntityIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type EntityIndexVariables = {
  pathParams: EntityIndexPathParams;
  queryParams?: EntityIndexQueryParams;
};

export const entityIndex = (variables: EntityIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    | {
        meta?: {
          /**
           * @example projects
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example projects
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.ProjectLightDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example sites
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example sites
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SiteLightDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example nurseries
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example nurseries
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.NurseryLightDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example projectReports
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example projectReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.ProjectReportLightDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example nurseryReports
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example nurseryReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.NurseryReportLightDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example siteReports
           */
          resourceType?: string;
          indices?: {
            /**
             * The resource type for this included index
             */
            resource?: string;
            /**
             * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
             */
            requestPath?: string;
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            pageNumber?: number;
            /**
             * The ordered set of resource IDs for this page of this index search.
             */
            ids?: string[];
          }[];
        };
        data?: {
          /**
           * @example siteReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SiteReportLightDto;
        }[];
      },
    EntityIndexError,
    undefined,
    {},
    EntityIndexQueryParams,
    EntityIndexPathParams
  >({ url: "/entities/v3/{entity}", method: "get", ...variables, signal });

export type EntityGetPathParams = {
  /**
   * Entity type to retrieve
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "nurseryReports" | "siteReports";
  /**
   * Entity UUID for resource to retrieve
   */
  uuid: string;
};

export type EntityGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type EntityGetVariables = {
  pathParams: EntityGetPathParams;
};

export const entityGet = (variables: EntityGetVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    | {
        meta?: {
          /**
           * @example projects
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example projects
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.ProjectFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example sites
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example sites
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SiteFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example nurseries
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example nurseries
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.NurseryFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example nurseries
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example nurseries
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.NurseryFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example projectReports
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example projectReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.ProjectReportFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example nurseryReports
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example nurseryReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.NurseryReportFullDto;
        };
      }
    | {
        meta?: {
          /**
           * @example siteReports
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example siteReports
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SiteReportFullDto;
        };
      },
    EntityGetError,
    undefined,
    {},
    {},
    EntityGetPathParams
  >({ url: "/entities/v3/{entity}/{uuid}", method: "get", ...variables, signal });

export type EntityDeletePathParams = {
  /**
   * Entity type to retrieve
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "nurseryReports" | "siteReports";
  /**
   * Entity UUID for resource to retrieve
   */
  uuid: string;
};

export type EntityDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type EntityDeleteResponse = {
  meta?: {
    resourceType?: "projects" | "sites";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type EntityDeleteVariables = {
  pathParams: EntityDeletePathParams;
};

export const entityDelete = (variables: EntityDeleteVariables, signal?: AbortSignal) =>
  entityServiceFetch<EntityDeleteResponse, EntityDeleteError, undefined, {}, {}, EntityDeletePathParams>({
    url: "/entities/v3/{entity}/{uuid}",
    method: "delete",
    ...variables,
    signal
  });

export type EntityUpdatePathParams = {
  /**
   * Entity type to retrieve
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "nurseryReports" | "siteReports";
  /**
   * Entity UUID for resource to retrieve
   */
  uuid: string;
};

export type EntityUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type EntityUpdateVariables = {
  body: Schemas.EntityUpdateBody;
  pathParams: EntityUpdatePathParams;
};

export const entityUpdate = (variables: EntityUpdateVariables, signal?: AbortSignal) =>
  entityServiceFetch<undefined, EntityUpdateError, Schemas.EntityUpdateBody, {}, {}, EntityUpdatePathParams>({
    url: "/entities/v3/{entity}/{uuid}",
    method: "patch",
    ...variables,
    signal
  });

export type EntityAssociationIndexPathParams = {
  /**
   * Entity type for associations
   */
  entity: "projects" | "sites" | "nurseries" | "projectReports" | "siteReports" | "nurseryReports";
  /**
   * Entity UUID for association
   */
  uuid: string;
  /**
   * Association type to retrieve
   */
  association: "demographics" | "seedings" | "treeSpecies" | "media" | "disturbances" | "invasives" | "stratas";
};

export type EntityAssociationIndexQueryParams = {
  ["sort[field]"]?: string;
  /**
   * @default ASC
   */
  ["sort[direction]"]?: "ASC" | "DESC";
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  search?: string;
  /**
   * Search query used for filtering selectable options in autocomplete fields.
   */
  searchFilter?: string;
  country?: string;
  status?: string;
  updateRequestStatus?: string;
  projectUuid?: string;
  nurseryUuid?: string;
  siteUuid?: string;
  /**
   * Filter by landscape 3-letter codes: gcb, grv, ikr
   */
  landscape?: string[];
  /**
   * Filter by organisation types
   */
  organisationType?: string[];
  /**
   * Filter by cohorts
   */
  cohort?: string[];
  /**
   * If the base entity supports it, this will load the first page of associated entities
   */
  sideloads?: Schemas.EntitySideload[];
  polygonStatus?: "no-polygons" | "submitted" | "approved" | "needs-more-information" | "draft";
  nothingToReport?: boolean;
  shortName?: string;
  /**
   * Filter by UUIDs
   */
  uuids?: string[];
  modelType?: string;
  /**
   * @default false
   */
  isGeotagged?: boolean;
  fileType?: string;
  /**
   * @default false
   */
  isPublic?: boolean;
  /**
   * @default false
   */
  isPrivate?: boolean;
  /**
   * @default false
   */
  isCover?: boolean;
};

export type EntityAssociationIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type EntityAssociationIndexVariables = {
  pathParams: EntityAssociationIndexPathParams;
  queryParams?: EntityAssociationIndexQueryParams;
};

export const entityAssociationIndex = (variables: EntityAssociationIndexVariables, signal?: AbortSignal) =>
  entityServiceFetch<
    | {
        meta?: {
          /**
           * @example demographics
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example demographics
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.DemographicDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example seedings
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example seedings
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SeedingDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example treeSpecies
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example treeSpecies
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.TreeSpeciesDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example media
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example media
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.MediaDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example disturbances
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example disturbances
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.DisturbanceDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example invasives
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example invasives
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.InvasiveDto;
        }[];
      }
    | {
        meta?: {
          /**
           * @example stratas
           */
          resourceType?: string;
        };
        data?: {
          /**
           * @example stratas
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.StrataDto;
        }[];
      },
    EntityAssociationIndexError,
    undefined,
    {},
    EntityAssociationIndexQueryParams,
    EntityAssociationIndexPathParams
  >({ url: "/entities/v3/{entity}/{uuid}/{association}", method: "get", ...variables, signal });

export const operationsByTag = {
  projectPitches: { projectPitchIndex, projectPitchGet },
  impactStories: { impactStoryIndex, impactStoryGet },
  tasks: { taskIndex, bulkApproveTasks, taskGet, taskUpdate },
  fileUpload: { uploadFile },
  trees: { treeScientificNamesSearch, establishmentTreesFind, treeReportCountsFind },
  demographics: { demographicsIndex },
  entities: { entityIndex, entityGet, entityDelete, entityUpdate },
  entityAssociations: { entityAssociationIndex }
};
