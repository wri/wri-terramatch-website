/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
export type IndicatorTreeCoverLossDto = {
  indicatorSlug: "treeCoverLoss" | "treeCoverLossFires";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * Mapping of year of analysis to value.
   *
   * @example {"2023":"0.5","2024":"0.6"}
   */
  value: Record<string, any>;
};

export type IndicatorHectaresDto = {
  indicatorSlug: "restorationByEcoRegion" | "restorationByStrategy" | "restorationByLandUse";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * Mapping of area type (eco region, land use, etc) to hectares
   *
   * @example {"Northern Acacia-Commiphora bushlands and thickets":0.104}
   */
  value: Record<string, any>;
};

export type IndicatorTreeCountDto = {
  indicatorSlug: "treeCount" | "earlyTreeVerification";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  surveyType: string | null;
  surveyId: number | null;
  treeCount: number | null;
  /**
   * @example types TBD
   */
  uncertaintyType: string | null;
  imagerySource: string | null;
  imageryId: string | null;
  projectPhase: string | null;
  confidence: number | null;
};

export type IndicatorTreeCoverDto = {
  indicatorSlug: "treeCover";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * @example 2024
   */
  projectPhase: string | null;
  percentCover: number | null;
  plusMinusPercent: number | null;
};

export type IndicatorFieldMonitoringDto = {
  indicatorSlug: "fieldMonitoring";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  treeCount: number | null;
  projectPhase: string | null;
  species: string | null;
  survivalRate: number | null;
};

export type IndicatorMsuCarbonDto = {
  indicatorSlug: "msuCarbon";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  carbonOutput: number | null;
  projectPhase: number | null;
  confidence: number | null;
};

export type TreeSpeciesDto = {
  /**
   * @example Acacia binervia
   */
  name: string;
  /**
   * @example 15000
   */
  amount: number | null;
};

export type ReportingPeriodDto = {
  /**
   * @format date-time
   */
  dueAt: string | null;
  /**
   * @format date-time
   */
  submittedAt: string | null;
  /**
   * The tree species reported as planted during this reporting period
   */
  treeSpecies: TreeSpeciesDto[];
};

export type SitePolygonFullDto = {
  /**
   * Indicates if this resource has the full resource definition.
   */
  lightResource: boolean;
  name: string | null;
  status: "draft" | "submitted" | "needs-more-information" | "approved";
  /**
   * If this ID points to a deleted site, the indicators will be empty.
   */
  siteId: string | null;
  /**
   * UUID of the associated polygon geometry
   */
  polygonUuid: string | null;
  projectId: string | null;
  projectShortName: string | null;
  /**
   * @format date-time
   */
  plantStart: string | null;
  calcArea: number | null;
  /**
   * Latitude of the site polygon
   */
  lat: number | null;
  /**
   * Longitude of the site polygon
   */
  long: number | null;
  /**
   * All indicators currently recorded for this site polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
  /**
   * The name of the associated Site.
   */
  siteName: string | null;
  versionName: string | null;
  practice: string | null;
  targetSys: string | null;
  distr: string | null;
  numTrees: number | null;
  /**
   * Source of the site polygon
   */
  source: string | null;
  /**
   * Validation status of the site polygon
   *
   * @maxLength 255
   */
  validationStatus: string | null;
  /**
   * Primary UUID of the site polygon
   */
  primaryUuid: string | null;
  /**
   * UUID of the site polygon
   */
  uuid: string;
  geometry: Record<string, any> | null;
  /**
   * The tree species associated with the establishment of the site that this polygon relates to.
   */
  establishmentTreeSpecies: TreeSpeciesDto[];
  /**
   * Access to reported trees planted for each approved report on this site.
   */
  reportingPeriods: ReportingPeriodDto[];
};

export type SitePolygonLightDto = {
  /**
   * Indicates if this resource has the full resource definition.
   */
  lightResource: boolean;
  name: string | null;
  status: "draft" | "submitted" | "needs-more-information" | "approved";
  /**
   * If this ID points to a deleted site, the indicators will be empty.
   */
  siteId: string | null;
  /**
   * UUID of the associated polygon geometry
   */
  polygonUuid: string | null;
  projectId: string | null;
  projectShortName: string | null;
  /**
   * @format date-time
   */
  plantStart: string | null;
  calcArea: number | null;
  /**
   * Latitude of the site polygon
   */
  lat: number | null;
  /**
   * Longitude of the site polygon
   */
  long: number | null;
  /**
   * All indicators currently recorded for this site polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
  /**
   * The name of the associated Site.
   */
  siteName: string | null;
  versionName: string | null;
  practice: string | null;
  targetSys: string | null;
  distr: string | null;
  numTrees: number | null;
  /**
   * Source of the site polygon
   */
  source: string | null;
  /**
   * Validation status of the site polygon
   *
   * @maxLength 255
   */
  validationStatus: string | null;
  /**
   * Primary UUID of the site polygon
   */
  primaryUuid: string | null;
  /**
   * UUID of the site polygon
   */
  uuid: string;
};

export type SitePolygonUpdateAttributes = {
  /**
   * All indicators to update for this polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
};

export type SitePolygonUpdate = {
  type: "sitePolygons";
  /**
   * @format uuid
   */
  id: string;
  attributes: SitePolygonUpdateAttributes;
};

export type SitePolygonBulkUpdateBodyDto = {
  data: SitePolygonUpdate[];
};

export type BoundingBoxDto = {
  /**
   * The bounding box coordinates in [minLng, minLat, maxLng, maxLat] format
   *
   * @example -13.17273163
   * @example -21.3169788
   * @example 48.8126753
   * @example 13.47775425
   */
  bbox: number[];
};

export type ValidationCriteriaDto = {
  /**
   * The validation criteria ID
   */
  criteriaId: 3 | 4 | 6 | 7 | 8 | 12 | 14 | 15;
  /**
   * Whether the polygon passed this validation
   */
  valid: boolean;
  /**
   * When this validation was last run
   *
   * @format date-time
   */
  createdAt: string;
  /**
   * Additional information about the validation result
   */
  extraInfo?: Record<string, any>;
};

export type ValidationDto = {
  /**
   * The UUID of the polygon that was validated
   *
   * @example d6502d4c-dfd6-461e-af62-21a0ec2f3e65
   */
  polygonUuid: string;
  /**
   * List of validation criteria results for this polygon
   */
  criteriaList: ValidationCriteriaDto[];
};

export type Object = {};

export type ValidationRequestAttributes = {
  /**
   * Array of polygon UUIDs to validate
   *
   * @example 7631be34-bbe0-4e1e-b4fe-592677dc4b50
   * @example d6502d4c-dfd6-461e-af62-21a0ec2f3e65
   */
  polygonUuids: string[];
  /**
   * Array of validation types to run. If not provided or empty, all validation types will be run.
   */
  validationTypes?: (
    | "OVERLAPPING"
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "ESTIMATED_AREA"
    | "DATA_COMPLETENESS"
    | "PLANT_START_DATE"
    | "OVERLAPPING"
    | "WITHIN_COUNTRY"
  )[];
};

export type ValidationRequestData = {
  type: "validations";
  attributes: ValidationRequestAttributes;
};

export type ValidationRequestBody = {
  data: ValidationRequestData;
};

export type ValidationSummaryDto = {
  /**
   * The UUID of the site that was validated
   *
   * @example 7631be34-bbe0-4e1e-b4fe-592677dc4b50
   */
  siteUuid: string;
  /**
   * Total number of polygons in the site
   */
  totalPolygons: number;
  /**
   * Number of polygons that were validated
   */
  validatedPolygons: number;
  /**
   * Summary of validation results by validation type
   */
  validationSummary: {
    [key: string]: {
      valid?: number;
      invalid?: number;
    };
  };
  /**
   * When the validation was completed
   *
   * @format date-time
   */
  completedAt: string;
};

export type DelayedJobDto = {
  /**
   * The unique identifier for the delayed job.
   */
  uuid: string;
  /**
   * The current status of the job. If the status is not pending, the payload and statusCode will be provided.
   */
  status: "pending" | "failed" | "succeeded";
  /**
   * If the job is out of pending state, this is the HTTP status code for the completed process
   */
  statusCode: number | null;
  /**
   * If the job is out of pending state, this is the JSON payload for the completed process
   */
  payload: Record<string, any> | null;
  /**
   * If the job is in progress, this is the total content to process
   */
  totalContent: number | null;
  /**
   * If the job is in progress, this is the total content processed
   */
  processedContent: number | null;
  /**
   * If the job is in progress, this is the progress message
   */
  progressMessage: string | null;
  /**
   * Indicates whether the jobs have been acknowledged (cleared)
   */
  isAcknowledged: boolean | null;
  /**
   * The name of the delayedJob
   */
  name: string | null;
  /**
   * The name of the related entity (e.g., Kerrawarra, New Site, etc).
   */
  entityName?: string | null;
};

export type SiteValidationRequestAttributes = {
  /**
   * Array of validation types to run on all polygons in the site. If not provided or empty, all validation types will be run.
   */
  validationTypes?: (
    | "OVERLAPPING"
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "ESTIMATED_AREA"
    | "DATA_COMPLETENESS"
    | "PLANT_START_DATE"
    | "OVERLAPPING"
    | "WITHIN_COUNTRY"
  )[];
};

export type SiteValidationRequestData = {
  type: "validations";
  attributes: SiteValidationRequestAttributes;
};

export type SiteValidationRequestBody = {
  data: SiteValidationRequestData;
};
