/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
export type IndicatorTreeCoverLossDto = {
  indicatorSlug: "treeCoverLoss" | "treeCoverLossFires";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * Mapping of year of analysis to value.
   *
   * @example {"2023":"0.5","2024":"0.6"}
   */
  value: Record<string, any>;
};

export type IndicatorHectaresDto = {
  indicatorSlug: "restorationByEcoRegion" | "restorationByStrategy" | "restorationByLandUse";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * Mapping of area type (eco region, land use, etc) to hectares
   *
   * @example {"Northern Acacia-Commiphora bushlands and thickets":0.104}
   */
  value: Record<string, any>;
};

export type IndicatorTreeCountDto = {
  indicatorSlug: "treeCount" | "earlyTreeVerification";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  surveyType: string | null;
  surveyId: number | null;
  treeCount: number | null;
  /**
   * @example types TBD
   */
  uncertaintyType: string | null;
  imagerySource: string | null;
  imageryId: string | null;
  projectPhase: string | null;
  confidence: number | null;
};

export type IndicatorTreeCoverDto = {
  indicatorSlug: "treeCover";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  /**
   * @example 2024
   */
  projectPhase: string | null;
  percentCover: number | null;
  plusMinusPercent: number | null;
};

export type IndicatorFieldMonitoringDto = {
  indicatorSlug: "fieldMonitoring";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  treeCount: number | null;
  projectPhase: string | null;
  species: string | null;
  survivalRate: number | null;
};

export type IndicatorMsuCarbonDto = {
  indicatorSlug: "msuCarbon";
  /**
   * @example 2024
   */
  yearOfAnalysis: number;
  carbonOutput: number | null;
  projectPhase: number | null;
  confidence: number | null;
};

export type ValidationCriteriaDto = {
  /**
   * The validation criteria ID
   *
   * @example 16
   */
  criteriaId: 3 | 4 | 6 | 7 | 8 | 12 | 14 | 15 | 16 | 5 | 10;
  /**
   * The validation type name (e.g., 'SELF_INTERSECTION', 'POLYGON_SIZE', 'DUPLICATE_GEOMETRY')
   *
   * @example DUPLICATE_GEOMETRY
   */
  validationType:
    | "OVERLAPPING"
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "ESTIMATED_AREA"
    | "DATA_COMPLETENESS"
    | "PLANT_START_DATE"
    | "DUPLICATE_GEOMETRY"
    | "WITHIN_COUNTRY"
    | "FEATURE_BOUNDS"
    | "GEOMETRY_TYPE";
  /**
   * Whether the polygon passed this validation
   *
   * @example false
   */
  valid: boolean;
  /**
   * When this validation was last run (null for non-persistent validations)
   *
   * @format date-time
   * @example 2025-11-28T20:41:50.060Z
   */
  createdAt: string | null;
  /**
   * Additional information about the validation result
   *
   * @example {"polygonUuid":"54aa2c7a-e139-4017-b86b-d904f4a3ed5c","message":"This geometry already exists in the project","sitePolygonUuid":"fd6cd4e8-0c56-45dc-8991-1cebfd3871ca","sitePolygonName":"AREA_NAME"}
   */
  extraInfo?: Record<string, any>;
};

export type ValidationDto = {
  /**
   * The UUID of the polygon that was validated
   *
   * @example d6502d4c-dfd6-461e-af62-21a0ec2f3e65
   */
  polygonUuid: string;
  /**
   * List of validation criteria results for this polygon
   *
   * @example {"criteriaId":16,"validationType":"DUPLICATE_GEOMETRY","valid":false,"createdAt":"2025-11-28T20:41:50.060Z","extraInfo":{"polygonUuid":"54aa2c7a-e139-4017-b86b-d904f4a3ed5c","message":"This geometry already exists in the project","sitePolygonUuid":"fd6cd4e8-0c56-45dc-8991-1cebfd3871ca","sitePolygonName":"AREA_NAME"}}
   */
  criteriaList: ValidationCriteriaDto[];
};

export type GeoJsonExportDto = {
  /**
   * @example FeatureCollection
   */
  type: "FeatureCollection";
  /**
   * Array of GeoJSON Feature objects
   *
   * @example {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[0,0],[0,1],[1,1],[1,0],[0,0]]]},"properties":{"uuid":"123e4567-e89b-12d3-a456-426614174000","polyName":"Forest Plot A","plantStart":"2024-01-01","practice":["direct-seeding"],"targetSys":"agroforestry","distr":["single-line"],"numTrees":1500,"siteId":"123e4567-e89b-12d3-a456-426614174001"}}
   */
  features: {
    type?: "Feature";
    geometry?: Record<string, any>;
    properties?: Record<string, any> | null;
  }[];
};

export type SitePolygonLightDto = {
  /**
   * Indicates if this resource has the full resource definition.
   */
  lightResource: boolean;
  name: string | null;
  status: "draft" | "submitted" | "needs-more-information" | "approved";
  /**
   * If this ID points to a deleted site, the indicators will be empty.
   */
  siteId: string | null;
  /**
   * UUID of the associated polygon geometry
   */
  polygonUuid: string | null;
  projectId: string | null;
  projectShortName: string | null;
  /**
   * @format date-time
   */
  plantStart: string | null;
  calcArea: number | null;
  /**
   * Latitude of the site polygon
   */
  lat: number | null;
  /**
   * Longitude of the site polygon
   */
  long: number | null;
  /**
   * All indicators currently recorded for this site polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
  /**
   * The name of the associated Site.
   */
  siteName: string | null;
  versionName: string | null;
  practice: string[] | null;
  targetSys: string | null;
  distr: string[] | null;
  numTrees: number | null;
  /**
   * Source of the site polygon
   */
  source: string | null;
  /**
   * Validation status of the site polygon
   *
   * @maxLength 255
   */
  validationStatus: string | null;
  /**
   * Primary UUID of the site polygon
   */
  primaryUuid: string | null;
  /**
   * UUID of the site polygon
   */
  uuid: string;
  disturbanceableId: number | null;
  /**
   * Whether the site polygon is active
   */
  isActive: boolean;
};

export type CreateSitePolygonRequestDto = {
  /**
   * Feature collection type (always 'FeatureCollection')
   *
   * @example FeatureCollection
   */
  type: string;
  /**
   * Array of features to create. Properties support both camelCase (primary/preferred) and snake_case (backward compatibility).
   *     camelCase takes precedence if both formats are present for the same property.
   *
   * @example {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[0,0],[0,1],[1,1],[1,0],[0,0]]]},"properties":{"siteId":"550e8400-e29b-41d4-a716-446655440000","polyName":"North Field","plantStart":"2023-01-15T00:00:00Z"}}
   */
  features: any[][];
};

export type AttributeChangesDto = {
  /**
   * Updated polygon name
   *
   * @example North Field Updated
   */
  polyName?: string;
  /**
   * Updated planting start date (ISO 8601 format)
   *
   * @example 2023-01-15T00:00:00Z
   */
  plantStart?: string;
  /**
   * Updated practice type(s) as array of strings
   *
   * @example tree-planting
   */
  practice?: string[];
  /**
   * Updated target system
   *
   * @example restoration
   */
  targetSys?: string;
  /**
   * Updated distribution method(s) as array of strings
   *
   * @example full
   * @example single-line
   */
  distr?: string[];
  /**
   * Updated number of trees
   *
   * @example 150
   */
  numTrees?: number;
  /**
   * Updated polygon name (snake_case, backward compatibility)
   *
   * @example North Field Updated
   */
  poly_name?: string;
  /**
   * Updated planting start date (snake_case, backward compatibility)
   *
   * @example 2023-01-15T00:00:00Z
   */
  plantstart?: string;
  /**
   * Updated target system (snake_case, backward compatibility)
   *
   * @example restoration
   */
  target_sys?: string;
  /**
   * Updated number of trees (snake_case, backward compatibility)
   *
   * @example 150
   */
  num_trees?: number;
};

export type CreateSitePolygonAttributesDto = {
  /**
   * Array of feature collections containing geometries to create or update.
   *
   *     Normal Creation (required):
   *     - Must provide `geometries` array
   *     - Attributes come from `properties` within each feature
   *     - Each feature must have `siteId` (camelCase, preferred) or `site_id` (snake_case, backward compatibility) in properties
   *
   *     Version Creation (optional):
   *     - Provide `geometries` to update geometry only, or together with `attributeChanges` to update both
   *     - When provided, only the geometry is used - feature properties are ignored
   *     - For attribute-only updates, omit this field and use `attributeChanges` instead
   *     - Must provide at least one of `geometries` or `attributeChanges` when creating a version
   *
   * @example {"type":"FeatureCollection","features":[{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[0,0],[0,1],[1,1],[1,0],[0,0]]]},"properties":{"siteId":"550e8400-e29b-41d4-a716-446655440000"}}]}
   */
  geometries?: CreateSitePolygonRequestDto[];
  /**
   * UUID of existing site polygon to create version from. When provided, creates a new version instead of a new polygon.
   *
   * @example 550e8400-e29b-41d4-a716-446655440000
   */
  baseSitePolygonUuid?: string;
  /**
   * Reason for creating version (optional when baseSitePolygonUuid is provided, defaults to 'Version created via API')
   *
   * @example Updated polygon boundary based on field survey data
   */
  changeReason?: string;
  /**
   * Attribute changes to apply when creating a version.
   *
   *     Only used when `baseSitePolygonUuid` is provided (version creation mode).
   *
   *     Version Creation Scenarios:
   *     - Attributes only: Provide `attributeChanges` without `geometries`
   *     - Both geometry and attributes: Provide both `geometries` and `attributeChanges`
   *     - Geometry only: Provide `geometries` without `attributeChanges`
   *
   *     Important: This is the ONLY way to update attributes during version creation.
   *     For normal creation, attributes should be provided in feature `properties` within `geometries`.
   *     Geometry properties are ignored during version creation - use this field instead.
   *
   *     `attributeChanges` supports both camelCase (primary/preferred) and snake_case (backward compatibility).
   *     camelCase takes precedence if both formats are present for the same property.
   *
   *     Must provide at least one of `geometries` or `attributeChanges` when creating a version.
   */
  attributeChanges?: AttributeChangesDto;
};

export type CreateSitePolygonDataDto = {
  /**
   * Resource type
   *
   * @example sitePolygons
   */
  type: string;
  /**
   * Attributes containing the geometries to create
   */
  attributes: CreateSitePolygonAttributesDto;
};

export type CreateSitePolygonJsonApiRequestDto = {
  /**
   * JSON:API data object
   */
  data: CreateSitePolygonDataDto;
};

export type TreeSpeciesDto = {
  /**
   * @example Acacia binervia
   */
  name: string;
  /**
   * @example 15000
   */
  amount: number | null;
};

export type ReportingPeriodDto = {
  /**
   * @format date-time
   */
  dueAt: string | null;
  /**
   * @format date-time
   */
  submittedAt: string | null;
  /**
   * The tree species reported as planted during this reporting period
   */
  treeSpecies: TreeSpeciesDto[];
};

export type SitePolygonFullDto = {
  /**
   * Indicates if this resource has the full resource definition.
   */
  lightResource: boolean;
  name: string | null;
  status: "draft" | "submitted" | "needs-more-information" | "approved";
  /**
   * If this ID points to a deleted site, the indicators will be empty.
   */
  siteId: string | null;
  /**
   * UUID of the associated polygon geometry
   */
  polygonUuid: string | null;
  projectId: string | null;
  projectShortName: string | null;
  /**
   * @format date-time
   */
  plantStart: string | null;
  calcArea: number | null;
  /**
   * Latitude of the site polygon
   */
  lat: number | null;
  /**
   * Longitude of the site polygon
   */
  long: number | null;
  /**
   * All indicators currently recorded for this site polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
  /**
   * The name of the associated Site.
   */
  siteName: string | null;
  versionName: string | null;
  practice: string[] | null;
  targetSys: string | null;
  distr: string[] | null;
  numTrees: number | null;
  /**
   * Source of the site polygon
   */
  source: string | null;
  /**
   * Validation status of the site polygon
   *
   * @maxLength 255
   */
  validationStatus: string | null;
  /**
   * Primary UUID of the site polygon
   */
  primaryUuid: string | null;
  /**
   * UUID of the site polygon
   */
  uuid: string;
  disturbanceableId: number | null;
  /**
   * Whether the site polygon is active
   */
  isActive: boolean;
  geometry: Record<string, any> | null;
  /**
   * The tree species associated with the establishment of the site that this polygon relates to.
   */
  establishmentTreeSpecies: TreeSpeciesDto[];
  /**
   * Access to reported trees planted for each approved report on this site.
   */
  reportingPeriods: ReportingPeriodDto[];
};

export type SitePolygonUpdateAttributes = {
  /**
   * All indicators to update for this polygon
   */
  indicators: (
    | IndicatorTreeCoverLossDto
    | IndicatorHectaresDto
    | IndicatorTreeCountDto
    | IndicatorTreeCoverDto
    | IndicatorFieldMonitoringDto
    | IndicatorMsuCarbonDto
  )[];
};

export type SitePolygonUpdate = {
  type: "sitePolygons";
  /**
   * @format uuid
   */
  id: string;
  attributes: SitePolygonUpdateAttributes;
};

export type SitePolygonBulkUpdateBodyDto = {
  data: SitePolygonUpdate[];
};

export type VersionUpdateAttributes = {
  /**
   * Set to true to activate this version, false to deactivate
   *
   * @example true
   */
  isActive: boolean;
  /**
   * Optional comment explaining the version change
   *
   * @example Activating this version to revert recent changes
   */
  comment?: string;
};

export type VersionUpdateData = {
  type: "sitePolygons";
  /**
   * @format uuid
   */
  id: string;
  attributes: VersionUpdateAttributes;
};

export type VersionUpdateBody = {
  data: VersionUpdateData;
};

export type DelayedJobDto = {
  /**
   * The unique identifier for the delayed job.
   */
  uuid: string;
  /**
   * The current status of the job. If the status is not pending, the payload and statusCode will be provided.
   */
  status: "pending" | "failed" | "succeeded";
  /**
   * If the job is out of pending state, this is the HTTP status code for the completed process
   */
  statusCode: number | null;
  /**
   * If the job is out of pending state, this is the JSON payload for the completed process
   */
  payload: Record<string, any> | null;
  /**
   * If the job is in progress, this is the total content to process
   */
  totalContent: number | null;
  /**
   * If the job is in progress, this is the total content processed
   */
  processedContent: number | null;
  /**
   * If the job is in progress, this is the progress message
   */
  progressMessage: string | null;
  /**
   * Indicates whether the jobs have been acknowledged (cleared)
   */
  isAcknowledged: boolean | null;
  /**
   * The name of the delayedJob
   */
  name: string | null;
  /**
   * The name of the related entity (e.g., Kerrawarra, New Site, etc).
   */
  entityName?: string | null;
};

export type GeometryUploadAttributesDto = {
  siteId: string;
};

export type GeometryUploadData = {
  type: "sitePolygons";
  attributes: GeometryUploadAttributesDto;
};

export type GeometryUploadRequestDto = {
  data: GeometryUploadData;
};

export type BoundingBoxDto = {
  /**
   * The bounding box coordinates in [minLng, minLat, maxLng, maxLat] format
   *
   * @example -13.17273163
   * @example -21.3169788
   * @example 48.8126753
   * @example 13.47775425
   */
  bbox: number[];
};

export type Object = {};

export type ValidationRequestAttributes = {
  /**
   * Array of polygon UUIDs to validate
   *
   * @example 7631be34-bbe0-4e1e-b4fe-592677dc4b50
   * @example d6502d4c-dfd6-461e-af62-21a0ec2f3e65
   */
  polygonUuids: string[];
  /**
   * Array of validation types to run. If not provided or empty, all validation types will be run.
   */
  validationTypes?: (
    | "OVERLAPPING"
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "ESTIMATED_AREA"
    | "DATA_COMPLETENESS"
    | "PLANT_START_DATE"
    | "DUPLICATE_GEOMETRY"
    | "WITHIN_COUNTRY"
    | "FEATURE_BOUNDS"
    | "GEOMETRY_TYPE"
  )[];
};

export type ValidationRequestData = {
  type: "validations";
  attributes: ValidationRequestAttributes;
};

export type ValidationRequestBody = {
  data: ValidationRequestData;
};

export type ValidationSummaryDto = {
  /**
   * The UUID of the site that was validated
   *
   * @example 7631be34-bbe0-4e1e-b4fe-592677dc4b50
   */
  siteUuid: string;
  /**
   * Total number of polygons in the site
   */
  totalPolygons: number;
  /**
   * Number of polygons that were validated
   */
  validatedPolygons: number;
  /**
   * When the validation was completed
   *
   * @format date-time
   */
  completedAt: string;
};

export type SiteValidationRequestAttributes = {
  /**
   * Array of validation types to run on all polygons in the site. If not provided or empty, all validation types will be run.
   */
  validationTypes?: (
    | "OVERLAPPING"
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "ESTIMATED_AREA"
    | "DATA_COMPLETENESS"
    | "PLANT_START_DATE"
    | "DUPLICATE_GEOMETRY"
    | "WITHIN_COUNTRY"
    | "FEATURE_BOUNDS"
    | "GEOMETRY_TYPE"
  )[];
};

export type SiteValidationRequestData = {
  type: "validations";
  attributes: SiteValidationRequestAttributes;
};

export type SiteValidationRequestBody = {
  data: SiteValidationRequestData;
};

export type GeometryValidationRequestAttributes = {
  /**
   * Array of GeoJSON FeatureCollections containing geometries to validate.
   *     Properties support both camelCase and snake_case.
   *     camelCase takes precedence if both formats are present for the same property.
   *
   * @example {"type":"FeatureCollection","features":[{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[0,0],[0,1],[1,1],[1,0],[0,0]]]},"properties":{"siteId":"550e8400-e29b-41d4-a716-446655440000","polyName":"Test Polygon"}}]}
   */
  geometries: any[];
  /**
   * Array of validation types to run. If not provided or empty, all non persistent validation types will be run.
   *
   * @example DUPLICATE_GEOMETRY
   */
  validationTypes?: (
    | "SELF_INTERSECTION"
    | "POLYGON_SIZE"
    | "SPIKES"
    | "DUPLICATE_GEOMETRY"
    | "DATA_COMPLETENESS"
    | "FEATURE_BOUNDS"
    | "GEOMETRY_TYPE"
  )[];
};

export type GeometryValidationRequestData = {
  type: "geometryValidations";
  attributes: GeometryValidationRequestAttributes;
};

export type GeometryValidationRequestBody = {
  data: GeometryValidationRequestData;
};

export type ClippedVersionDto = {
  /**
   * The UUID of the newly created polygon version
   *
   * @example 550e8400-e29b-41d4-a716-446655440000
   */
  uuid: string;
  /**
   * The name of the polygon
   *
   * @example Plot_1_2024
   */
  polyName: Record<string, any>;
  /**
   * The original area in hectares before clipping
   *
   * @example 2.5
   */
  originalArea: number;
  /**
   * The new area in hectares after clipping
   *
   * @example 2.35
   */
  newArea: number;
  /**
   * The area removed in hectares
   *
   * @example 0.15
   */
  areaRemoved: number;
};

export type PolygonListClippingAttributes = {
  /**
   * Array of polygon UUIDs to check and clip for fixable overlaps
   *
   * @example 550e8400-e29b-41d4-a716-446655440000
   * @example 660e8400-e29b-41d4-a716-446655440001
   */
  polygonUuids: string[];
};

export type PolygonListClippingData = {
  type: "polygon-clipping";
  attributes: PolygonListClippingAttributes;
};

export type PolygonListClippingRequestBody = {
  data: PolygonListClippingData;
};

export type IndicatorsAttributes = {
  /**
   * The UUIDs of the polygons to calculate indicators for
   *
   * @example 123e4567-e89b-12d3-a456-426614174000
   * @example 123e4567-e89b-12d3-a456-426614174001
   */
  polygonUuids: string[];
  /**
   * Whether to update the existing indicators
   *
   * @example true
   */
  updateExisting: boolean;
  /**
   * Whether to force recalculation of the indicators
   *
   * @example true
   */
  forceRecalculation: boolean;
};

export type IndicatorsRequestData = {
  type: "sitePolygons";
  attributes: IndicatorsAttributes;
};

export type IndicatorsBodyDto = {
  data: IndicatorsRequestData;
};
