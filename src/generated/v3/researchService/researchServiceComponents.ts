/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import { V3ApiEndpoint } from "../utils";
import type * as Fetcher from "./researchServiceFetcher";
import type * as Schemas from "./researchServiceSchemas";

export type CreateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type CreateSitePolygonsResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  };
  included?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  }[];
};

export type CreateSitePolygonsVariables = {
  body: Schemas.CreateSitePolygonJsonApiRequestDto;
};

/**
 * Create site polygons OR create a new version of an existing polygon.
 *
 *     Normal Creation (new polygons):
 *     - Provide `geometries` array with `siteId`in feature properties (required)
 *     - Attributes (polyName, plantstart, practice, etc.) come from feature `properties`
 *     - Properties support both camelCase and snake_case
 *     - Do NOT provide `baseSitePolygonUuid` or `attributeChanges`
 *
 *     Version Creation (new version of existing polygon):
 *     - Provide `baseSitePolygonUuid` (required) + `changeReason` (optional, defaults to "Version created via API")
 *     - Then provide ONE of the following:
 *       - Geometry only: Provide `geometries` array (geometry properties are ignored)
 *       - Attributes only: Provide `attributeChanges` object
 *       - Both: Provide both `geometries` and `attributeChanges`
 *     - At least one of `geometries` or `attributeChanges` must be provided
 *
 *     Important: When creating versions, `attributeChanges` is the ONLY way to update attributes.
 *     Geometry properties are ignored during version creation - use `attributeChanges` instead.
 *
 *     Duplicate validation results are included in the `included` section of the JSON:API response when duplicates are found.
 *     Property naming: GeoJSON properties support both camelCase and snake_case.
 */
export const createSitePolygons = new V3ApiEndpoint<
  CreateSitePolygonsResponse,
  CreateSitePolygonsError,
  CreateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "POST");

export type SitePolygonsIndexQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The last record before the page being requested. The value is a UUID. If page[after] is not provided, the first page is returned.
   */
  ["page[after]"]?: string;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter results by polygon status
   */
  ["polygonStatus[]"]?: ("draft" | "submitted" | "needs-more-information" | "approved")[];
  /**
   * Filter results by validation status
   */
  ["validationStatus[]"]?: string[];
  /**
   * Filter results by project UUID(s). May not be used with siteId[], projectCohort or landscape
   */
  ["projectId[]"]?: string[];
  /**
   * Filter results by project short name(s)
   */
  ["projectShortNames[]"]?: string[];
  /**
   * Filter results by site UUID(s). May not be used with projectId[], projectCohort or landscape
   */
  ["siteId[]"]?: string[];
  /**
   * Filter results by polygon UUID(s)
   */
  ["polygonUuid[]"]?: string[];
  /**
   * Filter results by project cohorts. May not be used with projectId[] or siteId[]
   */
  ["projectCohort[]"]?: string[];
  /**
   * Filter results by project landscape. May not be used with projectId[] or siteId[]
   */
  landscape?: "gcb" | "grv" | "ikr";
  /**
   * Filter results by polygons that are missing at least one of the indicators listed
   */
  ["missingIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have all of the indicators listed
   */
  ["presentIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have been modified since the date provided
   *
   * @format date-time
   */
  lastModifiedDate?: string;
  /**
   * Include polygons for test projects in the results.
   *
   * @default false
   */
  includeTestProjects?: boolean;
  search?: string;
  /**
   * Whether to include the complete sitePolygon Dto or not
   *
   * @default false
   */
  lightResource?: boolean;
};

export type SitePolygonsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type SitePolygonsIndexVariables = {
  queryParams?: SitePolygonsIndexQueryParams;
};

export const sitePolygonsIndex = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The cursor for the first record on this page.
           */
          cursor?: string;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonFullDto;
        meta?: {
          page?: {
            /**
             * The cursor for this record.
             */
            cursor?: string;
          };
        };
      }[];
    }
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The current page number.
           */
          pageNumber?: number;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      }[];
    },
  SitePolygonsIndexError,
  SitePolygonsIndexVariables,
  {}
>("/research/v3/sitePolygons", "GET");

export type BulkUpdateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkUpdateSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkUpdateBodyDto;
};

/**
 * If an indicator is provided that already exists, it will be updated with the value in the
 *        payload. If a new indicator is provided, it will be created in the DB. Indicators are keyed
 *        off of the combination of site polygon ID, indicatorSlug, and yearOfAnalysis.
 */
export const bulkUpdateSitePolygons = new V3ApiEndpoint<
  undefined,
  BulkUpdateSitePolygonsError,
  BulkUpdateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "PATCH");

export type BulkDeleteSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkDeleteSitePolygonsResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type BulkDeleteSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkDeleteBodyDto;
};

/**
 * Deletes multiple site polygons and all their associated records including indicators,
 *        criteria site records, audit statuses, and geometry data. This operation soft deletes
 *        ALL related site polygons by primaryUuid (version management) and deletes polygon
 *        geometry for all related site polygons. The request body follows JSON:API format with
 *        an array of resource identifiers (type and id).
 */
export const bulkDeleteSitePolygons = new V3ApiEndpoint<
  BulkDeleteSitePolygonsResponse,
  BulkDeleteSitePolygonsError,
  BulkDeleteSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "DELETE");

export type GetSitePolygonsGeoJsonQueryParams = {
  /**
   * UUID of a specific polygon
   *
   * @example 123e4567-e89b-12d3-a456-426614174000
   */
  uuid?: string;
  /**
   * UUID of a site to get all its polygons
   *
   * @example 123e4567-e89b-12d3-a456-426614174001
   */
  siteUuid?: string;
  /**
   * UUID of a project to get all its polygons across all sites
   *
   * @example 123e4567-e89b-12d3-a456-426614174002
   */
  projectUuid?: string;
  /**
   * Include extended data from site_polygon_data table
   *
   * @default true
   */
  includeExtendedData?: boolean;
  /**
   * Return only geometry without properties
   *
   * @default false
   */
  geometryOnly?: boolean;
};

export type GetSitePolygonsGeoJsonError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type GetSitePolygonsGeoJsonResponse = {
  meta?: {
    /**
     * @example geojsonExports
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example geojsonExports
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.GeoJsonExportDto;
  };
};

export type GetSitePolygonsGeoJsonVariables = {
  queryParams?: GetSitePolygonsGeoJsonQueryParams;
};

/**
 * Export site polygons as GeoJSON FeatureCollection.
 *     Provide exactly one of: uuid (single polygon), siteUuid (all active polygons in a site), or projectUuid (all active polygons across all sites in a project).
 *     Use includeExtendedData to include additional data from site_polygon_data table.
 *     Use geometryOnly to return only geometry without properties (only applicable when using uuid).
 */
export const getSitePolygonsGeoJson = new V3ApiEndpoint<
  GetSitePolygonsGeoJsonResponse,
  GetSitePolygonsGeoJsonError,
  GetSitePolygonsGeoJsonVariables,
  {}
>("/research/v3/sitePolygons/geojson", "GET");

export type UpdateSitePolygonStatusPathParams = {
  status: string;
};

export type UpdateSitePolygonStatusError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UpdateSitePolygonStatusResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
       */
      ids?: string[];
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
    }[];
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  }[];
};

export type UpdateSitePolygonStatusVariables = {
  body: Schemas.SitePolygonStatusBulkUpdateBodyDto;
  pathParams: UpdateSitePolygonStatusPathParams;
};

/**
 * Update the status of a site polygon
 */
export const updateSitePolygonStatus = new V3ApiEndpoint<
  UpdateSitePolygonStatusResponse,
  UpdateSitePolygonStatusError,
  UpdateSitePolygonStatusVariables,
  {}
>("/research/v3/sitePolygons/status/{status}", "PATCH");

export type ListSitePolygonVersionsPathParams = {
  primaryUuid: string;
};

export type ListSitePolygonVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type ListSitePolygonVersionsResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
       */
      ids?: string[];
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
    }[];
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  }[];
};

export type ListSitePolygonVersionsVariables = {
  pathParams: ListSitePolygonVersionsPathParams;
};

/**
 * Returns all versions sharing the same primaryUuid, ordered by creation date (newest first)
 */
export const listSitePolygonVersions = new V3ApiEndpoint<
  ListSitePolygonVersionsResponse,
  ListSitePolygonVersionsError,
  ListSitePolygonVersionsVariables,
  {}
>("/research/v3/sitePolygons/{primaryUuid}/versions", "GET");

export type UpdateSitePolygonVersionPathParams = {
  uuid: string;
};

export type UpdateSitePolygonVersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UpdateSitePolygonVersionResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  };
};

export type UpdateSitePolygonVersionVariables = {
  body: Schemas.VersionUpdateBody;
  pathParams: UpdateSitePolygonVersionPathParams;
};

/**
 * Update version properties. Setting isActive to true will activate this version and deactivate all others in the version group.
 *       Both admins and project developers can manage versions.
 */
export const updateSitePolygonVersion = new V3ApiEndpoint<
  UpdateSitePolygonVersionResponse,
  UpdateSitePolygonVersionError,
  UpdateSitePolygonVersionVariables,
  {}
>("/research/v3/sitePolygons/{uuid}/version", "PATCH");

export type DeleteSitePolygonVersionPathParams = {
  uuid: string;
};

export type DeleteSitePolygonVersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DeleteSitePolygonVersionResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type DeleteSitePolygonVersionVariables = {
  pathParams: DeleteSitePolygonVersionPathParams;
};

/**
 * Deletes a specific version of a site polygon. Restrictions:
 *        - Cannot delete the last version (use DELETE /:uuid to delete all versions)
 *        - Cannot delete the active version (activate another version first)
 *        - Only deletes polygon_geometry if not used by other versions
 *        - Deletes all associations (indicators, criteria_site, audit_status) for this version
 */
export const deleteSitePolygonVersion = new V3ApiEndpoint<
  DeleteSitePolygonVersionResponse,
  DeleteSitePolygonVersionError,
  DeleteSitePolygonVersionVariables,
  {}
>("/research/v3/sitePolygons/{uuid}/version", "DELETE");

export type DeleteSitePolygonPathParams = {
  uuid: string;
};

export type DeleteSitePolygonError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DeleteSitePolygonResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type DeleteSitePolygonVariables = {
  pathParams: DeleteSitePolygonPathParams;
};

/**
 * Deletes a site polygon and all its associated records including indicators,
 *        criteria site records, audit statuses, and geometry data. This operation soft deletes
 *        ALL related site polygons by primaryUuid (version management) and deletes polygon
 *        geometry for all related site polygons.
 */
export const deleteSitePolygon = new V3ApiEndpoint<
  DeleteSitePolygonResponse,
  DeleteSitePolygonError,
  DeleteSitePolygonVariables,
  {}
>("/research/v3/sitePolygons/{uuid}", "DELETE");

export type CompareGeometryFileError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CompareGeometryFileResponse = {
  meta?: {
    /**
     * @example geometryUploadComparisonSummaries
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example geometryUploadComparisonSummaries
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.GeometryUploadComparisonSummaryDto;
  };
};

export type CompareGeometryFileVariables = {
  body: Schemas.GeometryUploadRequestDto;
};

/**
 * Parses a geometry file and returns UUIDs of existing SitePolygons found in the database.
 */
export const compareGeometryFile = new V3ApiEndpoint<
  CompareGeometryFileResponse,
  CompareGeometryFileError,
  CompareGeometryFileVariables,
  {}
>("/research/v3/sitePolygons/upload/comparison", "POST");

export type UploadGeometryFileError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UploadGeometryFileVariables = {
  body: Schemas.GeometryUploadRequestDto;
};

/**
 * Parses a geometry file (KML, Shapefile, or GeoJSON) and creates site polygons asynchronously.
 *       Supported formats: KML (.kml), Shapefile (.zip with .shp/.shx/.dbf), GeoJSON (.geojson)
 */
export const uploadGeometryFile = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  UploadGeometryFileError,
  UploadGeometryFileVariables,
  {}
>("/research/v3/sitePolygons/upload", "POST");

export type UploadGeometryFileWithVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UploadGeometryFileWithVersionsVariables = {
  body: Schemas.GeometryUploadRequestDto;
};

/**
 * Parses a geometry file and processes it with versioning enabled.
 *       Features with UUIDs in properties.uuid that match existing active SitePolygons will create new versions.
 *       Features without matching UUIDs (or without UUIDs) will create new polygons.
 *       Attributes are extracted from GeoJSON feature properties for both versions and new polygons.
 *       Supported formats: KML (.kml), Shapefile (.zip with .shp/.shx/.dbf), GeoJSON (.geojson)
 */
export const uploadGeometryFileWithVersions = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  UploadGeometryFileWithVersionsError,
  UploadGeometryFileWithVersionsVariables,
  {}
>("/research/v3/sitePolygons/upload/versions", "POST");

export type BoundingBoxGetQueryParams = {
  /**
   * UUID of a polygon to get its bounding box
   */
  polygonUuid?: string;
  /**
   * UUID of a site to get the bounding box of all its polygons
   */
  siteUuid?: string;
  /**
   * UUID of a project to get the bounding box of all its site polygons
   */
  projectUuid?: string;
  /**
   * UUID of a project pitch to get the bounding box of all its polygons
   */
  projectPitchUuid?: string;
  /**
   * Array of landscape slugs for combined bounding box (used with country)
   */
  landscapes?: string[];
  /**
   * Country code (3-letter ISO) to get its bounding box
   */
  country?: string;
};

export type BoundingBoxGetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BoundingBoxGetResponse = {
  meta?: {
    /**
     * @example boundingBoxes
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example boundingBoxes
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.BoundingBoxDto;
  };
};

export type BoundingBoxGetVariables = {
  queryParams?: BoundingBoxGetQueryParams;
};

export const boundingBoxGet = new V3ApiEndpoint<
  BoundingBoxGetResponse,
  BoundingBoxGetError,
  BoundingBoxGetVariables,
  {}
>("/boundingBoxes/v3/get", "GET");

export type GetPolygonValidationPathParams = {
  polygonUuid: string;
};

export type GetPolygonValidationError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example 404
     */
    statusCode: number;
    /**
     * @example Not Found
     */
    message: string;
  };
}>;

export type GetPolygonValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetPolygonValidationVariables = {
  pathParams: GetPolygonValidationPathParams;
};

export const getPolygonValidation = new V3ApiEndpoint<
  GetPolygonValidationResponse,
  GetPolygonValidationError,
  GetPolygonValidationVariables,
  {}
>("/validations/v3/polygons/{polygonUuid}", "GET");

export type GetSiteValidationPathParams = {
  siteUuid: string;
};

export type GetSiteValidationQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter validations by criteria ID
   */
  criteriaId?: Schemas.Object;
};

export type GetSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type GetSiteValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetSiteValidationVariables = {
  pathParams: GetSiteValidationPathParams;
  queryParams?: GetSiteValidationQueryParams;
};

export const getSiteValidation = new V3ApiEndpoint<
  GetSiteValidationResponse,
  GetSiteValidationError,
  GetSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}", "GET");

export type CreatePolygonValidationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonValidationsResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type CreatePolygonValidationsVariables = {
  body: Schemas.ValidationRequestBody;
};

export const createPolygonValidations = new V3ApiEndpoint<
  CreatePolygonValidationsResponse,
  CreatePolygonValidationsError,
  CreatePolygonValidationsVariables,
  {}
>("/validations/v3/polygonValidations", "POST");

export type CreateSiteValidationPathParams = {
  siteUuid: string;
};

export type CreateSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateSiteValidationVariables = {
  body: Schemas.SiteValidationRequestBody;
  pathParams: CreateSiteValidationPathParams;
};

export const createSiteValidation = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example validationSummaries
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example validationSummaries
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ValidationSummaryDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  CreateSiteValidationError,
  CreateSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}/validation", "POST");

export type ValidateGeometriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type ValidateGeometriesResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type ValidateGeometriesVariables = {
  body: Schemas.GeometryValidationRequestBody;
};

/**
 * Validates raw GeoJSON geometries in-memory without persisting results to the database.
 *
 *     This endpoint is useful for validating geometries before creating site polygons, allowing you to check
 *     for issues without saving the data.
 *
 *     Input:
 *     - Provide an array of GeoJSON FeatureCollections containing the geometries to validate
 *     - Optionally specify which validation types to run (defaults to all non-persistent validation types)
 *
 *     Supported validation types (non-persistent):
 *     - SELF_INTERSECTION: Checks if polygon edges intersect with themselves
 *     - POLYGON_SIZE: Validates polygon area is within acceptable range ( 1000 ha )
 *     - SPIKES: Detects spikes in polygon boundaries
 *     - DUPLICATE_GEOMETRY: Checks if geometry already exists (requires siteId or site_id in feature properties)
 *     - DATA_COMPLETENESS: Validates required properties are present
 *     - FEATURE_BOUNDS: Validates geometry coordinates are within valid bounds
 *     - GEOMETRY_TYPE: Validates geometry type is supported (multipolygon, polygon or point)
 *
 *     Response:
 *     - Returns a JSON:API document with validation results in the `data` array
 *     - Each validation result contains a `polygonUuid` identifier (from feature properties.id if provided, otherwise auto-generated as "feature-{index}")
 *     - This identifier is NOT a database UUID - it's only used to match validation results back to the input features
 *     - Each result includes a `criteriaList` with validation details for each criteria checked
 *     - Results are not persisted to the database and are only returned in the response
 *
 *     Note: For duplicate geometry validation, features must include `siteId`in their properties.
 *
 *     Property naming: GeoJSON properties support both camelCase and snake_case.
 *     camelCase takes precedence if both formats are present for the same property.
 */
export const validateGeometries = new V3ApiEndpoint<
  ValidateGeometriesResponse,
  ValidateGeometriesError,
  ValidateGeometriesVariables,
  {}
>("/validations/v3/geometries", "POST");

export type CreateClippedVersionsQueryParams = {
  /**
   * Site UUID to clip polygons for all polygons in the site
   *
   * @format uuid
   */
  siteUuid?: string;
  /**
   * Project UUID to clip polygons for all polygons in the project
   *
   * @format uuid
   */
  projectUuid?: string;
};

export type CreateClippedVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateClippedVersionsVariables = {
  queryParams?: CreateClippedVersionsQueryParams;
};

/**
 * Finds and clips all fixable overlapping polygons (overlap ≤3.5% AND ≤0.118 hectares) for a site or project.
 *       Creates new versions asynchronously with clipped geometries. Returns a delayed job to track progress.
 *       Provide either siteUuid or projectUuid as a query parameter, but not both.
 */
export const createClippedVersions = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    }
  | {
      meta?: {
        /**
         * @example clippedVersions
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example clippedVersions
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ClippedVersionDto;
      };
    },
  CreateClippedVersionsError,
  CreateClippedVersionsVariables,
  {}
>("/polygonClipping/v3/clippedVersions", "POST");

export type CreatePolygonListClippedVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonListClippedVersionsVariables = {
  body: Schemas.PolygonListClippingRequestBody;
};

/**
 * Clips a specific list of polygons for fixable overlaps (≤3.5% AND ≤0.118 hectares).
 *       Creates new versions with clipped geometries. For a single polygon, returns immediately.
 *       For multiple polygons, returns a delayed job to track progress.
 */
export const createPolygonListClippedVersions = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    }
  | {
      meta?: {
        /**
         * @example clippedVersions
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example clippedVersions
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ClippedVersionDto;
      };
    },
  CreatePolygonListClippedVersionsError,
  CreatePolygonListClippedVersionsVariables,
  {}
>("/polygonClipping/v3/polygons", "POST");

export type StartIndicatorCalculationPathParams = {
  /**
   * Entity type for associations
   */
  slug:
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon";
};

export type StartIndicatorCalculationError = Fetcher.ErrorWrapper<undefined>;

export type StartIndicatorCalculationVariables = {
  body: Schemas.IndicatorsBodyDto;
  pathParams: StartIndicatorCalculationPathParams;
};

export const startIndicatorCalculation = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    }
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      };
    },
  StartIndicatorCalculationError,
  StartIndicatorCalculationVariables,
  {}
>("/research/v3/indicators/{slug}", "POST");

export const operationsByTag = {
  sitePolygons: {
    createSitePolygons,
    sitePolygonsIndex,
    bulkUpdateSitePolygons,
    bulkDeleteSitePolygons,
    getSitePolygonsGeoJson,
    updateSitePolygonStatus,
    listSitePolygonVersions,
    updateSitePolygonVersion,
    deleteSitePolygonVersion,
    deleteSitePolygon,
    compareGeometryFile,
    uploadGeometryFile,
    uploadGeometryFileWithVersions
  },
  boundingBoxes: { boundingBoxGet },
  validations: {
    getPolygonValidation,
    getSiteValidation,
    createPolygonValidations,
    createSiteValidation,
    validateGeometries
  },
  polygonClipping: { createClippedVersions, createPolygonListClippedVersions },
  indicators: { startIndicatorCalculation }
};
