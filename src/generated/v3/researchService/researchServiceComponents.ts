/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import { V3ApiEndpoint } from "../utils";
import type * as Fetcher from "./researchServiceFetcher";
import type * as Schemas from "./researchServiceSchemas";

export type CreateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type CreateSitePolygonsResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  };
};

export type CreateSitePolygonsVariables = {
  body: Schemas.CreateSitePolygonJsonApiRequestDto;
};

/**
 * Create site polygons. Supports multi-site batch creation.
 *       Duplicate validation results are always included in the response when duplicates are found.
 */
export const createSitePolygons = new V3ApiEndpoint<
  CreateSitePolygonsResponse,
  CreateSitePolygonsError,
  CreateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "POST");

export type SitePolygonsIndexQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The last record before the page being requested. The value is a UUID. If page[after] is not provided, the first page is returned.
   */
  ["page[after]"]?: string;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter results by polygon status
   */
  ["polygonStatus[]"]?: ("draft" | "submitted" | "needs-more-information" | "approved")[];
  /**
   * Filter results by validation status
   */
  ["validationStatus[]"]?: string[];
  /**
   * Filter results by project UUID(s). May not be used with siteId[], projectCohort or landscape
   */
  ["projectId[]"]?: string[];
  /**
   * Filter results by project short name(s)
   */
  ["projectShortNames[]"]?: string[];
  /**
   * Filter results by site UUID(s). May not be used with projectId[], projectCohort or landscape
   */
  ["siteId[]"]?: string[];
  /**
   * Filter results by polygon UUID(s)
   */
  ["polygonUuid[]"]?: string[];
  /**
   * Filter results by project cohorts. May not be used with projectId[] or siteId[]
   */
  ["projectCohort[]"]?: string[];
  /**
   * Filter results by project landscape. May not be used with projectId[] or siteId[]
   */
  landscape?: "gcb" | "grv" | "ikr";
  /**
   * Filter results by polygons that are missing at least one of the indicators listed
   */
  ["missingIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have all of the indicators listed
   */
  ["presentIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have been modified since the date provided
   *
   * @format date-time
   */
  lastModifiedDate?: string;
  /**
   * Include polygons for test projects in the results.
   *
   * @default false
   */
  includeTestProjects?: boolean;
  search?: string;
  /**
   * Whether to include the complete sitePolygon Dto or not
   *
   * @default false
   */
  lightResource?: boolean;
};

export type SitePolygonsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type SitePolygonsIndexVariables = {
  queryParams?: SitePolygonsIndexQueryParams;
};

export const sitePolygonsIndex = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The cursor for the first record on this page.
           */
          cursor?: string;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonFullDto;
        meta?: {
          page?: {
            /**
             * The cursor for this record.
             */
            cursor?: string;
          };
        };
      }[];
    }
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The current page number.
           */
          pageNumber?: number;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      }[];
    },
  SitePolygonsIndexError,
  SitePolygonsIndexVariables,
  {}
>("/research/v3/sitePolygons", "GET");

export type BulkUpdateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkUpdateSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkUpdateBodyDto;
};

/**
 * If an indicator is provided that already exists, it will be updated with the value in the
 *        payload. If a new indicator is provided, it will be created in the DB. Indicators are keyed
 *        off of the combination of site polygon ID, indicatorSlug, and yearOfAnalysis.
 */
export const bulkUpdateSitePolygons = new V3ApiEndpoint<
  undefined,
  BulkUpdateSitePolygonsError,
  BulkUpdateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "PATCH");

export type DeleteSitePolygonPathParams = {
  uuid: string;
};

export type DeleteSitePolygonError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DeleteSitePolygonResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type DeleteSitePolygonVariables = {
  pathParams: DeleteSitePolygonPathParams;
};

/**
 * Deletes a site polygon and all its associated records including indicators,
 *        criteria site records, audit statuses, and geometry data. This operation soft deletes
 *        ALL related site polygons by primaryUuid (version management) and deletes polygon
 *        geometry for all related site polygons.
 */
export const deleteSitePolygon = new V3ApiEndpoint<
  DeleteSitePolygonResponse,
  DeleteSitePolygonError,
  DeleteSitePolygonVariables,
  {}
>("/research/v3/sitePolygons/{uuid}", "DELETE");

export type UploadGeometryFileError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UploadGeometryFileVariables = {
  body: Schemas.GeometryUploadRequestDto;
};

/**
 * Parses a geometry file (KML, Shapefile, or GeoJSON) and creates site polygons asynchronously.
 *       Supported formats: KML (.kml), Shapefile (.zip with .shp/.shx/.dbf), GeoJSON (.geojson)
 */
export const uploadGeometryFile = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  UploadGeometryFileError,
  UploadGeometryFileVariables,
  {}
>("/research/v3/sitePolygons/geometry/upload", "POST");

export type BoundingBoxGetQueryParams = {
  /**
   * UUID of a polygon to get its bounding box
   */
  polygonUuid?: string;
  /**
   * UUID of a site to get the bounding box of all its polygons
   */
  siteUuid?: string;
  /**
   * UUID of a project to get the bounding box of all its site polygons
   */
  projectUuid?: string;
  /**
   * UUID of a project pitch to get the bounding box of all its polygons
   */
  projectPitchUuid?: string;
  /**
   * Array of landscape slugs for combined bounding box (used with country)
   */
  landscapes?: string[];
  /**
   * Country code (3-letter ISO) to get its bounding box
   */
  country?: string;
};

export type BoundingBoxGetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BoundingBoxGetResponse = {
  meta?: {
    /**
     * @example boundingBoxes
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example boundingBoxes
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.BoundingBoxDto;
  };
};

export type BoundingBoxGetVariables = {
  queryParams?: BoundingBoxGetQueryParams;
};

export const boundingBoxGet = new V3ApiEndpoint<
  BoundingBoxGetResponse,
  BoundingBoxGetError,
  BoundingBoxGetVariables,
  {}
>("/boundingBoxes/v3/get", "GET");

export type GetPolygonValidationPathParams = {
  polygonUuid: string;
};

export type GetPolygonValidationError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example 404
     */
    statusCode: number;
    /**
     * @example Not Found
     */
    message: string;
  };
}>;

export type GetPolygonValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetPolygonValidationVariables = {
  pathParams: GetPolygonValidationPathParams;
};

export const getPolygonValidation = new V3ApiEndpoint<
  GetPolygonValidationResponse,
  GetPolygonValidationError,
  GetPolygonValidationVariables,
  {}
>("/validations/v3/polygons/{polygonUuid}", "GET");

export type GetSiteValidationPathParams = {
  siteUuid: string;
};

export type GetSiteValidationQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter validations by criteria ID
   */
  criteriaId?: Schemas.Object;
};

export type GetSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type GetSiteValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetSiteValidationVariables = {
  pathParams: GetSiteValidationPathParams;
  queryParams?: GetSiteValidationQueryParams;
};

export const getSiteValidation = new V3ApiEndpoint<
  GetSiteValidationResponse,
  GetSiteValidationError,
  GetSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}", "GET");

export type CreatePolygonValidationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonValidationsResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type CreatePolygonValidationsVariables = {
  body: Schemas.ValidationRequestBody;
};

export const createPolygonValidations = new V3ApiEndpoint<
  CreatePolygonValidationsResponse,
  CreatePolygonValidationsError,
  CreatePolygonValidationsVariables,
  {}
>("/validations/v3/polygonValidations", "POST");

export type CreateSiteValidationPathParams = {
  siteUuid: string;
};

export type CreateSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateSiteValidationVariables = {
  body: Schemas.SiteValidationRequestBody;
  pathParams: CreateSiteValidationPathParams;
};

export const createSiteValidation = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example validationSummaries
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example validationSummaries
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ValidationSummaryDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  CreateSiteValidationError,
  CreateSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}/validation", "POST");

export type ValidateGeometriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type ValidateGeometriesResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type ValidateGeometriesVariables = {
  body: Schemas.GeometryValidationRequestBody;
};

/**
 * Validates geometries in-memory without persisting results to database. Returns validation results in included array.
 */
export const validateGeometries = new V3ApiEndpoint<
  ValidateGeometriesResponse,
  ValidateGeometriesError,
  ValidateGeometriesVariables,
  {}
>("/validations/v3/geometries", "POST");

export type CreateSitePolygonClippingPathParams = {
  siteUuid: string;
};

export type CreateSitePolygonClippingError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateSitePolygonClippingVariables = {
  pathParams: CreateSitePolygonClippingPathParams;
};

/**
 * Finds and clips all fixable overlapping polygons in a site (overlap ≤3.5% AND ≤0.118 hectares).
 *       Returns GeoJSON of original and clipped polygons for verification.
 */
export const createSitePolygonClipping = new V3ApiEndpoint<
  undefined,
  CreateSitePolygonClippingError,
  CreateSitePolygonClippingVariables,
  {}
>("/polygonClipping/v3/sites/{siteUuid}/clippedPolygons", "POST");

export type CreateProjectPolygonClippingPathParams = {
  siteUuid: string;
};

export type CreateProjectPolygonClippingError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateProjectPolygonClippingVariables = {
  pathParams: CreateProjectPolygonClippingPathParams;
};

/**
 * Finds all polygons in a project (via site UUID) and clips fixable overlaps (≤3.5% AND ≤0.118 hectares).
 *       Returns GeoJSON of original and clipped polygons for verification.
 */
export const createProjectPolygonClipping = new V3ApiEndpoint<
  undefined,
  CreateProjectPolygonClippingError,
  CreateProjectPolygonClippingVariables,
  {}
>("/polygonClipping/v3/projects/{siteUuid}/clippedPolygons", "POST");

export type CreatePolygonListClippingError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonListClippingVariables = {
  body: Schemas.PolygonListClippingRequestBody;
};

/**
 * Clips a specific list of polygons for fixable overlaps (≤3.5% AND ≤0.118 hectares).
 *       Returns GeoJSON of original and clipped polygons for verification.
 *       Does NOT modify the database or create new versions yet.
 */
export const createPolygonListClipping = new V3ApiEndpoint<
  undefined,
  CreatePolygonListClippingError,
  CreatePolygonListClippingVariables,
  {}
>("/polygonClipping/v3/polygons", "POST");

export const operationsByTag = {
  sitePolygons: {
    createSitePolygons,
    sitePolygonsIndex,
    bulkUpdateSitePolygons,
    deleteSitePolygon,
    uploadGeometryFile
  },
  boundingBoxes: { boundingBoxGet },
  validations: {
    getPolygonValidation,
    getSiteValidation,
    createPolygonValidations,
    createSiteValidation,
    validateGeometries
  },
  polygonClipping: { createSitePolygonClipping, createProjectPolygonClipping, createPolygonListClipping }
};
