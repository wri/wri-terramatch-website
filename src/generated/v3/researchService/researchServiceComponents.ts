/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import type * as Fetcher from "./researchServiceFetcher";
import { researchServiceFetch } from "./researchServiceFetcher";
import type * as Schemas from "./researchServiceSchemas";

export type SitePolygonsIndexQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The last record before the page being requested. The value is a UUID. If neither page[after] nor page[number] is provided, the first page is returned.
   */
  ["page[after]"]?: string;
  /**
   * Filter results by polygon status
   */
  ["polygonStatus[]"]?: ("draft" | "submitted" | "needs-more-information" | "approved")[];
  /**
   * Filter results by project UUID(s). If specified, the includeTestProjects param is ignored
   */
  ["projectId[]"]?: string[];
  /**
   * Filter results by site UUID(s). If specified, the includeTestProjects param is ignored
   */
  ["siteId[]"]?: string[];
  /**
   * Filter results by polygons that are missing at least one of the indicators listed
   */
  ["missingIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have been modified since the date provided
   *
   * @format date-time
   */
  lastModifiedDate?: string;
  /**
   * Filter results by polygons that intersect with the boundary of the polygon referenced by this UUID
   */
  boundaryPolygon?: string;
  /**
   * Include polygons for test projects in the results. If an explicit list of project UUIDs is included in projectId[], this parameter is ignored.
   *
   * @default false
   */
  includeTestProjects?: boolean;
};

export type SitePolygonsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type SitePolygonsIndexResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    page?: {
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
      /**
       * The cursor for the first record on this page.
       */
      cursor?: string;
    };
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonDto;
    meta?: {
      page?: {
        /**
         * The cursor for this record.
         */
        cursor?: string;
      };
    };
  }[];
};

export type SitePolygonsIndexVariables = {
  queryParams?: SitePolygonsIndexQueryParams;
};

export const sitePolygonsIndex = (variables: SitePolygonsIndexVariables, signal?: AbortSignal) =>
  researchServiceFetch<
    SitePolygonsIndexResponse,
    SitePolygonsIndexError,
    undefined,
    {},
    SitePolygonsIndexQueryParams,
    {}
  >({ url: "/research/v3/sitePolygons", method: "get", ...variables, signal });

export type BulkUpdateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkUpdateSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkUpdateBodyDto;
};

/**
 * If an indicator is provided that already exists, it will be updated with the value in the
 *        payload. If a new indicator is provided, it will be created in the DB. Indicators are keyed
 *        off of the combination of site polygon ID, indicatorSlug, and yearOfAnalysis.
 */
export const bulkUpdateSitePolygons = (variables: BulkUpdateSitePolygonsVariables, signal?: AbortSignal) =>
  researchServiceFetch<undefined, BulkUpdateSitePolygonsError, Schemas.SitePolygonBulkUpdateBodyDto, {}, {}, {}>({
    url: "/research/v3/sitePolygons",
    method: "patch",
    ...variables,
    signal
  });

export const operationsByTag = { sitePolygons: { sitePolygonsIndex, bulkUpdateSitePolygons } };
