/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import type * as Fetcher from "./researchServiceFetcher";
import { researchServiceFetch } from "./researchServiceFetcher";
import type * as Schemas from "./researchServiceSchemas";

export type SitePolygonsIndexQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The last record before the page being requested. The value is a UUID. If page[after] is not provided, the first page is returned.
   */
  ["page[after]"]?: string;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter results by polygon status
   */
  ["polygonStatus[]"]?: ("draft" | "submitted" | "needs-more-information" | "approved")[];
  /**
   * Filter results by project UUID(s). Only one of siteId, projectId and includeTestProjects may be used in a single request
   */
  ["projectId[]"]?: string[];
  /**
   * Filter results by site UUID(s). Only one of siteId, projectId and includeTestProjects may be used in a single request
   */
  ["siteId[]"]?: string[];
  /**
   * Filter results by polygons that are missing at least one of the indicators listed
   */
  ["missingIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have all of the indicators listed
   */
  ["presentIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have been modified since the date provided
   *
   * @format date-time
   */
  lastModifiedDate?: string;
  /**
   * Filter results by polygons that intersect with the boundary of the polygon referenced by this UUID
   */
  boundaryPolygon?: string;
  /**
   * Include polygons for test projects in the results. Only one of siteId, projectId and includeTestProjects may be used in a single request
   *
   * @default false
   */
  includeTestProjects?: boolean;
  search?: string;
  /**
   * Wheter to include the complete sitePolygon Dto or not
   *
   * @default false
   */
  lightResource?: boolean;
};

export type SitePolygonsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type SitePolygonsIndexVariables = {
  queryParams?: SitePolygonsIndexQueryParams;
};

export const sitePolygonsIndex = (variables: SitePolygonsIndexVariables, signal?: AbortSignal) =>
  researchServiceFetch<
    | {
        meta?: {
          /**
           * @example sitePolygons
           */
          resourceType?: string;
          page?: {
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The cursor for the first record on this page.
             */
            cursor?: string;
          };
        };
        data?: {
          /**
           * @example sitePolygons
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SitePolygonFullDto;
          meta?: {
            page?: {
              /**
               * The cursor for this record.
               */
              cursor?: string;
            };
          };
        }[];
      }
    | {
        meta?: {
          /**
           * @example sitePolygons
           */
          resourceType?: string;
          page?: {
            /**
             * The total number of records available.
             *
             * @example 42
             */
            total?: number;
            /**
             * The current page number.
             */
            number?: number;
          };
        };
        data?: {
          /**
           * @example sitePolygons
           */
          type?: string;
          /**
           * @format uuid
           */
          id?: string;
          attributes?: Schemas.SitePolygonLightDto;
        }[];
      },
    SitePolygonsIndexError,
    undefined,
    {},
    SitePolygonsIndexQueryParams,
    {}
  >({ url: "/research/v3/sitePolygons", method: "get", ...variables, signal });

export type BulkUpdateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkUpdateSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkUpdateBodyDto;
};

/**
 * If an indicator is provided that already exists, it will be updated with the value in the
 *        payload. If a new indicator is provided, it will be created in the DB. Indicators are keyed
 *        off of the combination of site polygon ID, indicatorSlug, and yearOfAnalysis.
 */
export const bulkUpdateSitePolygons = (variables: BulkUpdateSitePolygonsVariables, signal?: AbortSignal) =>
  researchServiceFetch<undefined, BulkUpdateSitePolygonsError, Schemas.SitePolygonBulkUpdateBodyDto, {}, {}, {}>({
    url: "/research/v3/sitePolygons",
    method: "patch",
    ...variables,
    signal
  });

export const operationsByTag = { sitePolygons: { sitePolygonsIndex, bulkUpdateSitePolygons } };
