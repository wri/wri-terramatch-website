/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import { V3ApiEndpoint } from "../utils";
import type * as Fetcher from "./researchServiceFetcher";
import type * as Schemas from "./researchServiceSchemas";

export type CreateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type CreateSitePolygonsResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  };
};

export type CreateSitePolygonsVariables = {
  body: Schemas.CreateSitePolygonJsonApiRequestDto;
};

/**
 * Create site polygons OR create a new version of an existing polygon.
 *     **Normal Creation**: Provide geometries array with site_id in properties.
 *     **Version Creation**: Provide baseSitePolygonUuid + changeReason + (geometries and/or attributeChanges).
 *     Duplicate validation results are always included in the response when duplicates are found.
 */
export const createSitePolygons = new V3ApiEndpoint<
  CreateSitePolygonsResponse,
  CreateSitePolygonsError,
  CreateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "POST");

export type SitePolygonsIndexQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The last record before the page being requested. The value is a UUID. If page[after] is not provided, the first page is returned.
   */
  ["page[after]"]?: string;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter results by polygon status
   */
  ["polygonStatus[]"]?: ("draft" | "submitted" | "needs-more-information" | "approved")[];
  /**
   * Filter results by validation status
   */
  ["validationStatus[]"]?: string[];
  /**
   * Filter results by project UUID(s). May not be used with siteId[], projectCohort or landscape
   */
  ["projectId[]"]?: string[];
  /**
   * Filter results by project short name(s)
   */
  ["projectShortNames[]"]?: string[];
  /**
   * Filter results by site UUID(s). May not be used with projectId[], projectCohort or landscape
   */
  ["siteId[]"]?: string[];
  /**
   * Filter results by polygon UUID(s)
   */
  ["polygonUuid[]"]?: string[];
  /**
   * Filter results by project cohorts. May not be used with projectId[] or siteId[]
   */
  ["projectCohort[]"]?: string[];
  /**
   * Filter results by project landscape. May not be used with projectId[] or siteId[]
   */
  landscape?: "gcb" | "grv" | "ikr";
  /**
   * Filter results by polygons that are missing at least one of the indicators listed
   */
  ["missingIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have all of the indicators listed
   */
  ["presentIndicator[]"]?: (
    | "treeCover"
    | "treeCoverLoss"
    | "treeCoverLossFires"
    | "restorationByEcoRegion"
    | "restorationByStrategy"
    | "restorationByLandUse"
    | "treeCount"
    | "earlyTreeVerification"
    | "fieldMonitoring"
    | "msuCarbon"
  )[];
  /**
   * Filter results by polygons that have been modified since the date provided
   *
   * @format date-time
   */
  lastModifiedDate?: string;
  /**
   * Include polygons for test projects in the results.
   *
   * @default false
   */
  includeTestProjects?: boolean;
  search?: string;
  /**
   * Whether to include the complete sitePolygon Dto or not
   *
   * @default false
   */
  lightResource?: boolean;
};

export type SitePolygonsIndexError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
>;

export type SitePolygonsIndexVariables = {
  queryParams?: SitePolygonsIndexQueryParams;
};

export const sitePolygonsIndex = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The cursor for the first record on this page.
           */
          cursor?: string;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonFullDto;
        meta?: {
          page?: {
            /**
             * The cursor for this record.
             */
            cursor?: string;
          };
        };
      }[];
    }
  | {
      meta?: {
        /**
         * @example sitePolygons
         */
        resourceType?: string;
        indices?: {
          /**
           * The resource type for this included index
           */
          resource?: string;
          /**
           * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
           */
          requestPath?: string;
          /**
           * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
           */
          ids?: string[];
          /**
           * The current page number.
           */
          pageNumber?: number;
          /**
           * The total number of records available.
           *
           * @example 42
           */
          total?: number;
        }[];
      };
      data?: {
        /**
         * @example sitePolygons
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.SitePolygonLightDto;
      }[];
    },
  SitePolygonsIndexError,
  SitePolygonsIndexVariables,
  {}
>("/research/v3/sitePolygons", "GET");

export type BulkUpdateSitePolygonsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BulkUpdateSitePolygonsVariables = {
  body: Schemas.SitePolygonBulkUpdateBodyDto;
};

/**
 * If an indicator is provided that already exists, it will be updated with the value in the
 *        payload. If a new indicator is provided, it will be created in the DB. Indicators are keyed
 *        off of the combination of site polygon ID, indicatorSlug, and yearOfAnalysis.
 */
export const bulkUpdateSitePolygons = new V3ApiEndpoint<
  undefined,
  BulkUpdateSitePolygonsError,
  BulkUpdateSitePolygonsVariables,
  {}
>("/research/v3/sitePolygons", "PATCH");

export type ListSitePolygonVersionsPathParams = {
  uuid: string;
};

export type ListSitePolygonVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type ListSitePolygonVersionsResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
    indices?: {
      /**
       * The resource type for this included index
       */
      resource?: string;
      /**
       * The full stable (sorted query param) request path for this request, suitable for use as a store key in the FE React app
       */
      requestPath?: string;
      /**
       * The ordered set of resource IDs for this index. If this is omitted, the ids in the main `data` object of the response should be used.
       */
      ids?: string[];
      /**
       * The total number of records available.
       *
       * @example 42
       */
      total?: number;
    }[];
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  }[];
};

export type ListSitePolygonVersionsVariables = {
  pathParams: ListSitePolygonVersionsPathParams;
};

/**
 * Returns all versions sharing the same primaryUuid, ordered by creation date (newest first)
 */
export const listSitePolygonVersions = new V3ApiEndpoint<
  ListSitePolygonVersionsResponse,
  ListSitePolygonVersionsError,
  ListSitePolygonVersionsVariables,
  {}
>("/research/v3/sitePolygons/{uuid}/versions", "GET");

export type UpdateSitePolygonVersionPathParams = {
  uuid: string;
};

export type UpdateSitePolygonVersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type UpdateSitePolygonVersionResponse = {
  meta?: {
    /**
     * @example sitePolygons
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example sitePolygons
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.SitePolygonLightDto;
  };
};

export type UpdateSitePolygonVersionVariables = {
  body: Schemas.VersionUpdateBody;
  pathParams: UpdateSitePolygonVersionPathParams;
};

/**
 * Update version properties. Setting isActive to true will activate this version and deactivate all others in the version group.
 *       Both admins and project developers can manage versions.
 */
export const updateSitePolygonVersion = new V3ApiEndpoint<
  UpdateSitePolygonVersionResponse,
  UpdateSitePolygonVersionError,
  UpdateSitePolygonVersionVariables,
  {}
>("/research/v3/sitePolygons/{uuid}/version", "PATCH");

export type DeleteSitePolygonVersionPathParams = {
  uuid: string;
};

export type DeleteSitePolygonVersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DeleteSitePolygonVersionResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type DeleteSitePolygonVersionVariables = {
  pathParams: DeleteSitePolygonVersionPathParams;
};

/**
 * Deletes a specific version of a site polygon. Restrictions:
 *        - Cannot delete the last version (use DELETE /:uuid to delete all versions)
 *        - Cannot delete the active version (activate another version first)
 *        - Only deletes polygon_geometry if not used by other versions
 *        - Deletes all associations (indicators, criteria_site, audit_status) for this version
 */
export const deleteSitePolygonVersion = new V3ApiEndpoint<
  DeleteSitePolygonVersionResponse,
  DeleteSitePolygonVersionError,
  DeleteSitePolygonVersionVariables,
  {}
>("/research/v3/sitePolygons/{uuid}/version", "DELETE");

export type DeleteSitePolygonPathParams = {
  uuid: string;
};

export type DeleteSitePolygonError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type DeleteSitePolygonResponse = {
  meta?: {
    resourceType?: "sitePolygons" | "sitePolygons";
    /**
     * @format uuid
     */
    resourceId?: string;
  };
};

export type DeleteSitePolygonVariables = {
  pathParams: DeleteSitePolygonPathParams;
};

/**
 * Deletes a site polygon and all its associated records including indicators,
 *        criteria site records, audit statuses, and geometry data. This operation soft deletes
 *        ALL related site polygons by primaryUuid (version management) and deletes polygon
 *        geometry for all related site polygons.
 */
export const deleteSitePolygon = new V3ApiEndpoint<
  DeleteSitePolygonResponse,
  DeleteSitePolygonError,
  DeleteSitePolygonVariables,
  {}
>("/research/v3/sitePolygons/{uuid}", "DELETE");

export type BoundingBoxGetQueryParams = {
  /**
   * UUID of a polygon to get its bounding box
   */
  polygonUuid?: string;
  /**
   * UUID of a site to get the bounding box of all its polygons
   */
  siteUuid?: string;
  /**
   * UUID of a project to get the bounding box of all its site polygons
   */
  projectUuid?: string;
  /**
   * UUID of a project pitch to get the bounding box of all its polygons
   */
  projectPitchUuid?: string;
  /**
   * Array of landscape slugs for combined bounding box (used with country)
   */
  landscapes?: string[];
  /**
   * Country code (3-letter ISO) to get its bounding box
   */
  country?: string;
};

export type BoundingBoxGetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type BoundingBoxGetResponse = {
  meta?: {
    /**
     * @example boundingBoxes
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example boundingBoxes
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.BoundingBoxDto;
  };
};

export type BoundingBoxGetVariables = {
  queryParams?: BoundingBoxGetQueryParams;
};

export const boundingBoxGet = new V3ApiEndpoint<
  BoundingBoxGetResponse,
  BoundingBoxGetError,
  BoundingBoxGetVariables,
  {}
>("/boundingBoxes/v3/get", "GET");

export type GetPolygonValidationPathParams = {
  polygonUuid: string;
};

export type GetPolygonValidationError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example 404
     */
    statusCode: number;
    /**
     * @example Not Found
     */
    message: string;
  };
}>;

export type GetPolygonValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetPolygonValidationVariables = {
  pathParams: GetPolygonValidationPathParams;
};

export const getPolygonValidation = new V3ApiEndpoint<
  GetPolygonValidationResponse,
  GetPolygonValidationError,
  GetPolygonValidationVariables,
  {}
>("/validations/v3/polygons/{polygonUuid}", "GET");

export type GetSiteValidationPathParams = {
  siteUuid: string;
};

export type GetSiteValidationQueryParams = {
  /**
   * The size of page being requested
   *
   * @minimum 1
   * @maximum 100
   * @default 100
   */
  ["page[size]"]?: number;
  /**
   * The page number to return. If page[number] is not provided, the first page is returned.
   */
  ["page[number]"]?: number;
  /**
   * Filter validations by criteria ID
   */
  criteriaId?: Schemas.Object;
};

export type GetSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type GetSiteValidationResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type GetSiteValidationVariables = {
  pathParams: GetSiteValidationPathParams;
  queryParams?: GetSiteValidationQueryParams;
};

export const getSiteValidation = new V3ApiEndpoint<
  GetSiteValidationResponse,
  GetSiteValidationError,
  GetSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}", "GET");

export type CreatePolygonValidationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonValidationsResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type CreatePolygonValidationsVariables = {
  body: Schemas.ValidationRequestBody;
};

export const createPolygonValidations = new V3ApiEndpoint<
  CreatePolygonValidationsResponse,
  CreatePolygonValidationsError,
  CreatePolygonValidationsVariables,
  {}
>("/validations/v3/polygonValidations", "POST");

export type CreateSiteValidationPathParams = {
  siteUuid: string;
};

export type CreateSiteValidationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateSiteValidationVariables = {
  body: Schemas.SiteValidationRequestBody;
  pathParams: CreateSiteValidationPathParams;
};

export const createSiteValidation = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example validationSummaries
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example validationSummaries
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ValidationSummaryDto;
      };
    }
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    },
  CreateSiteValidationError,
  CreateSiteValidationVariables,
  {}
>("/validations/v3/sites/{siteUuid}/validation", "POST");

export type ValidateGeometriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example 400
     */
    statusCode: number;
    /**
     * @example Bad Request
     */
    message: string;
  };
}>;

export type ValidateGeometriesResponse = {
  meta?: {
    /**
     * @example validations
     */
    resourceType?: string;
  };
  data?: {
    /**
     * @example validations
     */
    type?: string;
    /**
     * @format uuid
     */
    id?: string;
    attributes?: Schemas.ValidationDto;
  };
};

export type ValidateGeometriesVariables = {
  body: Schemas.GeometryValidationRequestBody;
};

/**
 * Validates geometries in-memory without persisting results to database. Returns validation results in included array.
 */
export const validateGeometries = new V3ApiEndpoint<
  ValidateGeometriesResponse,
  ValidateGeometriesError,
  ValidateGeometriesVariables,
  {}
>("/validations/v3/geometries", "POST");

export type CreateClippedVersionsQueryParams = {
  /**
   * Site UUID to clip polygons for all polygons in the site
   *
   * @format uuid
   */
  siteUuid?: string;
  /**
   * Project UUID to clip polygons for all polygons in the project
   *
   * @format uuid
   */
  projectUuid?: string;
};

export type CreateClippedVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreateClippedVersionsVariables = {
  queryParams?: CreateClippedVersionsQueryParams;
};

/**
 * Finds and clips all fixable overlapping polygons (overlap ≤3.5% AND ≤0.118 hectares) for a site or project.
 *       Creates new versions asynchronously with clipped geometries. Returns a delayed job to track progress.
 *       Provide either siteUuid or projectUuid as a query parameter, but not both.
 */
export const createClippedVersions = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    }
  | {
      meta?: {
        /**
         * @example clippedVersions
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example clippedVersions
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ClippedVersionDto;
      };
    },
  CreateClippedVersionsError,
  CreateClippedVersionsVariables,
  {}
>("/polygonClipping/v3/clippedVersions", "POST");

export type CreatePolygonListClippedVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        /**
         * @example Bad Request
         */
        message: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        /**
         * @example Unauthorized
         */
        message: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        /**
         * @example Not Found
         */
        message: string;
      };
    }
>;

export type CreatePolygonListClippedVersionsVariables = {
  body: Schemas.PolygonListClippingRequestBody;
};

/**
 * Clips a specific list of polygons for fixable overlaps (≤3.5% AND ≤0.118 hectares).
 *       Creates new versions with clipped geometries. For a single polygon, returns immediately.
 *       For multiple polygons, returns a delayed job to track progress.
 */
export const createPolygonListClippedVersions = new V3ApiEndpoint<
  | {
      meta?: {
        /**
         * @example delayedJobs
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example delayedJobs
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.DelayedJobDto;
      };
    }
  | {
      meta?: {
        /**
         * @example clippedVersions
         */
        resourceType?: string;
      };
      data?: {
        /**
         * @example clippedVersions
         */
        type?: string;
        /**
         * @format uuid
         */
        id?: string;
        attributes?: Schemas.ClippedVersionDto;
      };
    },
  CreatePolygonListClippedVersionsError,
  CreatePolygonListClippedVersionsVariables,
  {}
>("/polygonClipping/v3/polygons", "POST");

export const operationsByTag = {
  sitePolygons: {
    createSitePolygons,
    sitePolygonsIndex,
    bulkUpdateSitePolygons,
    listSitePolygonVersions,
    updateSitePolygonVersion,
    deleteSitePolygonVersion,
    deleteSitePolygon
  },
  boundingBoxes: { boundingBoxGet },
  validations: {
    getPolygonValidation,
    getSiteValidation,
    createPolygonValidations,
    createSiteValidation,
    validateGeometries
  },
  polygonClipping: { createClippedVersions, createPolygonListClippedVersions }
};
